{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"attribution_parameterization/","title":"Attributions for Different Use Cases","text":""},{"location":"attribution_parameterization/#attribution-parameterization","title":"Attribution Parameterization","text":"<p>Attributions for different models and use cases can range from simple to more complex. This will help see how to set the various parameters to get what you need.</p>"},{"location":"attribution_parameterization/#basic-definitions-and-terminology","title":"Basic Definitions and Terminology","text":"<p>What is a tensor? A tensor is a multidimensional object that can be model inputs, or layer activations.</p> <p>What is a layer? A layer is a set of neurons that can be thought of as a function on input tensors. Layer inputs are tensors. Layer outputs are modified tensors.</p> <p>What are anchors? Anchors are ways of specifying which tensors you want. You may want the input tensor of a layer, or the output tensor of a layer. </p> <p>Eg: Say you have a concat layer and you want to explain the 2 concatenated tensors. The concat operation is not usually a layer tracked by the model. If you try the 'in' anchor of the layer after the operation, you get a single tensor with all the information you need.</p> <p>What is a Quantity of Interest (QoI)? A QoI is a scalar number that is being explained. </p> <p>Eg: With saliency maps, you get <code>dx/dy</code> (i.e the effect of input on output). <code>y</code> in this case is the QoI scalar. It is usually the output of a neuron, but could be a sum of multiple neurons.</p> <p>What is an attribution? An attribution is a numerical value associated with every element in a tensor that explains a QoI. </p> <p>Eg: With saliency maps, you get <code>dx/dy</code>. <code>x</code> is the associated tensor. The entirety of <code>dx/dy</code> is the explanation.</p> <p>What are cuts? Cuts are tensors that cut a network into two parts. They are composed of a layer and an anchor.</p> <p>What are slices? Slices are two cuts leaving a <code>slice</code> of the network. The attribution will be on the first cut, explaining the QoI on the second cut of the slice.</p> <p>Eg: With saliency maps, the trulens slice would be AttributionCut:<code>Cut(x)</code> to QoICut:<code>Cut(y)</code> denoted by <code>Slice(Cut(x),Cut(y))</code>.</p>"},{"location":"attribution_parameterization/#how-to-use-trulens","title":"How to use Trulens?","text":"<p>This section will cover different use cases from the most basic to the most complex.</p>"},{"location":"attribution_parameterization/#case-1-input-output-cut-basic-configuration","title":"Case 1: Input-Output cut (Basic configuration)","text":"<p>Use case: Explain the input given the output. Cuts needed: Trulens Defaults. Attribution Cut (The tensor we would like to assign importance) \u2192 InputCut aka model args/kwargs QoI Cut (The tensor that we are interested to explain) \u2192 OutputCut</p>"},{"location":"attribution_parameterization/#case-2-the-qoi-cut","title":"Case 2: The QoI Cut","text":"<p>Now suppose you want to explain some internal layer\u2019s output (intermediate output). i.e how the input is affecting the output at some intermediate layer.</p> <p>Use case: Explain something that isn't the default model output. Eg: If you want to explain a logit layer instead of the probit layer (the final layer). Cuts needed: As you want to explain something different than the default output, you need to change the QoI from the default to the layer that you are interested. Attribution Cut \u2192 InputCut QoI Cut \u2192 Your logit layer, anchor:'out'</p>"},{"location":"attribution_parameterization/#case-3-the-attribution-cut","title":"Case 3: The Attribution Cut","text":"<p>Now suppose you want to know the attribution of some internal layer on the final output. </p> <p>Use cases: </p> <ul> <li>As a preprocessing step, you drop a feature, so do not need attributions on that.</li> <li>For torch models, model inputs are not tensors. so you'd want the 'in' anchor of the first layer.  </li> </ul> <p>Cuts needed: As you want to know the affect of some other layer rather than the input layer, you need to customize the attribution cut. Model inputs \u2192 InputCut Attribution Cut \u2192 Your attribution layer (The layer you want to assign importance/attributions with respect to output), anchor:'in' QoI Cut \u2192 OutputCut</p>"},{"location":"attribution_parameterization/#advanced-use-cases","title":"Advanced Use Cases","text":"<p>For the following use cases, it may help to see the Advanced Definitions</p>"},{"location":"attribution_parameterization/#case-4-the-distribution-of-interest-doi-cut-explanation-flexibility","title":"Case 4: The Distribution of Interest (DoI) Cut / Explanation flexibility","text":"<p>Usually, we explain the output with respect to each point in the input. All cases up to now were using a default called PointDoI. Now, suppose you want to explain using an aggregate over samples of points.  </p> <p>Use case: You want to do integrated gradients, gradcam, shapley values instead of saliency maps. These only differ by sampling strategies. Eg: Integrated gradients is a sample from a straight line from a baseline to a value. Cuts needed: Define a DoI that samples from the default attribution cut. Model inputs \u2192 InputCut DoI/Attribution Cut \u2192 Your baseline/DoI/attribution layer, anchor:'in' QoI Cut \u2192 OutputCut</p>"},{"location":"attribution_parameterization/#case-5-internal-explanations","title":"Case 5: Internal explanations","text":"<p>Use case: You want to explain an internal layer. Things like integrated gradients are a DoI on the baseline to the value, but it is on the layer the baseline is defined. If you want to explain an internal layer, you do not move the DoI layer. Cuts needed: Attribution layer different from DoI. Model inputs \u2192 InputCut DoI Cut \u2192 Your baseline/DoI layer, anchor:'in' Attribution Cut \u2192 Your internal attribution layer, anchor:'out' or 'in' QoI Cut \u2192 OutputCut</p>"},{"location":"attribution_parameterization/#case-6-your-baseline-happens-at-a-different-layer-than-your-sampling","title":"Case 6: Your baseline happens at a different layer than your sampling.","text":"<p>Use Case: in NLP, baselines are tokens, but the interpolation is on the embedding layer. Cuts needed: Baseline different from DoI. Model inputs \u2192 InputCut Baseline Cut \u2192  tokens, anchor:'out' DoI/Attribution Cut \u2192 embeddings, anchor:'out' QoI Cut \u2192 OutputCut</p>"},{"location":"attribution_parameterization/#case-7-putting-it-together-the-most-complex-one-one-we-can-do-with-our-trulens","title":"Case 7: Putting it together - The most complex one one we can do with our Trulens","text":"<p>Use Case: Internal layer explanations of NLP, on the logit layer of a model with probit outputs. Model inputs \u2192 InputCut Baseline Cut \u2192 tokens, anchor:'out' DoI Cut \u2192 embeddings, anchor:'out' Attribution Cut \u2192 Internal layer, anchor:'out' QoI Cut \u2192 logit layer, anchor:'out'</p>"},{"location":"attribution_parameterization/#summary","title":"Summary","text":"<p>InputCut is model args / kwargs. OutputCut is the model output.</p> <p>Baseline Cut is the tensor associated with the Integrated gradients baseline. Can be the InputCut or later. DoI Cut is the tensor associated with explanation sampling. Can be the BaselineCut or later. Attribution Cut is the tensor that should be explained. Can be the DoICut or later. QoI Cut is what is being explained with a QoI. Must be after the AttributionCut.  </p>"},{"location":"attribution_parameterization/#advanced-definitions","title":"Advanced Definitions","text":"<p>What is a Distribution of Interest (DoI)?</p> <p>The distribution of interest is a concept of aggregating attributions over a sample or distribution. </p> <ul> <li>GradCam does this over a guassian distribution of inputs. </li> <li>Shapley values do this over different background data. </li> <li>Integrated gradients does this over an interpolation from a baseline to the input.</li> </ul> <p>How does this relate to the Attribution Cut?</p> <p>The sample or distributions are taken at a place that is humanly considered the input, even if this differs from the programatic model input.</p> <p>For attributions, all parts of a network can have have an attribution towards the QoI. It is that the most common use case is to explain the tensors that are also the humanly considered input (which is where the DoI occurs).</p> <p>How does this relate to the Baseline Cut?</p> <p>The Baseline Cut is only applicable to the Integrated Gradients method. It is also only needed when there is no mathematical way to interpolate the baseline to the input.</p> <p>Eg. if the input is 'Hello', but the baseline is a '[MASK]' token, we cannot interpolate that. We define the baseline at the token layer, but interpolate on a numeric layer like the embeddings.</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#getting-access-to-trulens","title":"Getting access to TruLens","text":"<p>These installation instructions assume that you have conda installed and added to your path.</p> <ol> <li> <p>Create a virtual environment (or modify an existing one). <pre><code>conda create -n \"&lt;my_name&gt;\" python=3.7  # Skip if using existing environment.\nconda activate &lt;my_name&gt;\n</code></pre></p> </li> <li> <p>Install dependencies. <pre><code>conda install tensorflow-gpu=1  # Or whatever backend you're using.\nconda install keras             # Or whatever backend you're using.\nconda install matplotlib        # For visualizations.\n</code></pre></p> </li> <li> <p>[Pip installation] Install the trulens pip package. <pre><code>pip install trulens\n</code></pre></p> </li> <li> <p>[Local installation] If you would like to develop or modify trulens, you can download the source code by cloning the trulens repo. <pre><code>git clone https://github.com/truera/trulens.git\n</code></pre></p> </li> <li> <p>[Locall installation] Install the trulens repo. <pre><code>cd trulens\npip install -e .\n</code></pre></p> </li> </ol>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#quickstart","title":"Quickstart","text":""},{"location":"quickstart/#playground","title":"Playground","text":"<p>To quickly play around with the TruLens library, check out the following CoLab notebooks:</p> <ul> <li>PyTorch: </li> <li>Tensorflow 2 / Keras: </li> </ul>"},{"location":"quickstart/#install-use","title":"Install &amp; Use","text":"<p>Check out the Installation instructions for information on how to install the library, use it, and contribute. </p>"},{"location":"welcome/","title":"Welcome to TruLens!","text":"<p>TruLens is a cross-framework library for deep learning explainability. It provides a uniform abstraction over a number of different frameworks. It provides a uniform abstraction layer over TensorFlow, Pytorch, and Keras and allows input and internal explanations.</p> <p>This paper is an introduction to the theoretical foundations of the library. We\u2019ve been using TruLens at TruEra across a wide range of real-world use cases to explain deep learning models ranging from time-series RNNs to image and NLP models, and wanted to share the awesomeness with the world.</p> <p>Documentation</p>"},{"location":"welcome/#quick-usage","title":"Quick Usage","text":"<p>To quickly play around with the TruLens library, check out the following CoLab notebooks:</p> <ul> <li>PyTorch: </li> <li>Tensorflow 2 / Keras: </li> <li>NLP with PyTorch: </li> <li>NLP with Tensorflow 2 / Keras: </li> </ul>"},{"location":"welcome/#installation","title":"Installation","text":"<p>These installation instructions assume that you have conda installed and added to your path.</p> <ol> <li>Create a virtual environment (or modify an existing one). <pre><code>conda create -n \"&lt;my_name&gt;\" python=3.7  # Skip if using existing environment.\nconda activate &lt;my_name&gt;\n</code></pre></li> <li>Install dependencies. <pre><code>conda install tensorflow-gpu=1  # Or whatever backend you're using.\nconda install keras             # Or whatever backend you're using.\nconda install matplotlib        # For visualizations.\n</code></pre></li> <li>Install the trulens package <pre><code>pip install trulens\n</code></pre></li> </ol>"},{"location":"welcome/#overview","title":"Overview","text":""},{"location":"welcome/#attributions","title":"Attributions","text":""},{"location":"welcome/#model-wrappers","title":"Model Wrappers","text":"<p>In order to support a wide variety of backends with different interfaces for their respective models, TruLens uses its own <code>ModelWrapper</code> class which provides a general model interface to simplify the implementation of the API functions. To get the model wrapper, use the <code>get_model_wrapper</code> method in <code>trulens.nn.models</code>. A model wrapper class exists for each backend that converts a model in the respective backend's format to the general TruLens <code>ModelWrapper</code> interface. The wrappers are found in the <code>models</code> module, and any model defined using Keras, Pytorch, or Tensorflow should be wrapped before being used with the other API functions that require a model -- all other TruLens functionalities expect models to be an instance of <code>trulens.nn.models.ModelWrapper</code>.</p> <p>For example,</p> <pre><code>from trulens.nn.models import get_model_wrapper\nwrapped_model = get_model_wrapper(model_defined_via_keras)\n</code></pre>"},{"location":"welcome/#attribution-methods","title":"Attribution Methods","text":"<p>Attribution methods, in the most general sense, allow us to quantify the contribution of particular variables in a model towards a particular behavior of the model. In many cases, for example, this may simply measure the effect each input variable has on the output of the network.</p> <p>Attribution methods extend the <code>AttributionMethod</code> class, and many concrete instances are found in the <code>trulens.nn.attribution</code> module.</p> <p>Once an attribution method has been instantiated, its main function is its <code>attributions</code> method, which returns an <code>np.Array</code> of batched items, where each item matches the shape of the input to the model the attribution method was instantiated with.</p> <p>See the method comparison demo for further information on the different types of attribution methods, their uses, and their relationships with one another.</p>"},{"location":"welcome/#slices-quantities-and-distributions","title":"Slices, Quantities, and Distributions","text":"<p>In order to obtain a high degree of flexibility in the types of attributions that can be produced, we implement Internal Influence, which is parameterized by a slice, quantity of interest, and distribution of interest, explained below.</p> <p>The slice essentially defines a layer to use for internal attributions. The slice for the <code>InternalInfluence</code> method can be specified by an instance of the <code>Slice</code> class in the <code>trulens.nn.slices</code> module. A <code>Slice</code> object specifies two layers: (1) the layer of the variables that we are calculating attribution for (e.g., the input layer), and (2) the layer whose output defines our quantity of interest (e.g., the output layer, see below for more on quantities of interest).</p> <p>The quantity of interest (QoI) essentially defines the model behavior we would like to explain using attributions. The QoI is a function of the model's output at some layer. For example, it may select the confidence score for a particular class. In its most general form, the QoI can be pecified by an implementation of the <code>QoI</code> class in the <code>trulens.nn.quantities</code> module. Several common default implementations are provided in this module as well.</p> <p>The distribution of interest (DoI) essentially specifies for which points surrounding each record the calculated attribution should be valid. The distribution can be specified via an implementation of the <code>DoI</code> class in the <code>trulens.nn.distributions</code> module, which is a function taking an input record and producing a list of sample input points to aggregate attribution over. A few common default distributions implementing the <code>DoI</code> class can be found in the <code>trulens.nn.distributions</code> module. </p> <p>See Attributions for Different Use Cases for further explanations of the purpose of these parameters and examples of their usage.</p>"},{"location":"welcome/#visualizations","title":"Visualizations","text":"<p>In order to interpret the attributions produced by an <code>AttributionMethod</code>, a few useful visualizers are provided in the <code>trulens.visualizations</code> module. While the interface of each visualizer varies slightly, in general, the visualizers are a function taking an <code>np.Array</code> representing the attributions returned from an <code>AttributionMethod</code> and producing an image that can be used to interpret the attributions.</p>"},{"location":"welcome/#contact-us","title":"Contact Us","text":"<p>To communicate with other trulens developers, join our Slack!</p>"},{"location":"welcome/#citation","title":"Citation","text":"<p>To cite this repository: <code>curl -LH \"Accept: application/x-bibtex\" https://doi.org/10.5281/zenodo.4495856</code></p>"},{"location":"api/attribution/","title":"Attribution Methods","text":"<p>Attribution methods quantitatively measure the contribution of each of a  function's individual inputs to its output. Gradient-based attribution methods compute the gradient of a model with respect to its inputs to describe how important each input is towards the output prediction. These methods can be applied to assist in explaining deep networks.</p> <p>TruLens provides implementations of several such techniques, found in this package.</p>"},{"location":"api/attribution/#trulens.nn.attribution.AttributionMethod","title":"<code>AttributionMethod</code>","text":"<p>         Bases: <code>AbstractBaseClass</code></p> <p>Interface used by all attribution methods.</p> <p>An attribution method takes a neural network model and provides the ability to assign values to the variables of the network that specify the importance of each variable towards particular predictions.</p> Source code in <code>trulens/nn/attribution.py</code> <pre><code>class AttributionMethod(AbstractBaseClass):\n\"\"\"\n    Interface used by all attribution methods.\n\n    An attribution method takes a neural network model and provides the ability\n    to assign values to the variables of the network that specify the importance\n    of each variable towards particular predictions.\n    \"\"\"\n\n    @abstractmethod\n    def __init__(\n        self, model: ModelWrapper, rebatch_size: int = None, *args, **kwargs\n    ):\n\"\"\"\n        Abstract constructor.\n\n        Parameters:\n            model: ModelWrapper\n                Model for which attributions are calculated.\n\n            rebatch_size: int (optional)\n                Will rebatch instances to this size if given. This may be\n                required for GPU usage if using a DoI which produces multiple\n                instances per user-provided instance. Many valued DoIs will\n                expand the tensors sent to each layer to original_batch_size *\n                doi_size. The rebatch size will break up original_batch_size *\n                doi_size into rebatch_size chunks to send to model.\n        \"\"\"\n        self._model = model\n\n        self.rebatch_size = rebatch_size\n\n    @property\n    def model(self) -&gt; ModelWrapper:\n\"\"\"\n        Model for which attributions are calculated.\n        \"\"\"\n        return self._model\n\n    @abstractmethod\n    def _attributions(self, model_inputs: ModelInputs) -&gt; AttributionResult:\n\"\"\"\n        For attributions that have options to return multiple things depending\n        on configuration, wrap those multiple things in the AttributionResult\n        tuple.\n        \"\"\"\n        ...\n\n    def attributions(\n        self, *model_args: ArgsLike, **model_kwargs: KwargsLike\n    ) -&gt; Union[TensorLike, ArgsLike[TensorLike],\n               ArgsLike[ArgsLike[TensorLike]]]:\n\"\"\"\n        Returns attributions for the given input. Attributions are in the same\n        shape as the layer that attributions are being generated for. \n\n        The numeric scale of the attributions will depend on the specific\n        implementations of the Distribution of Interest and Quantity of\n        Interest. However it is generally related to the scale of gradients on\n        the Quantity of Interest. \n\n        For example, Integrated Gradients uses the linear interpolation\n        Distribution of Interest which subsumes the completeness axiom which\n        ensures the sum of all attributions of a record equals the output\n        determined by the Quantity of Interest on the same record. \n\n        The Point Distribution of Interest will be determined by the gradient at\n        a single point, thus being a good measure of model sensitivity. \n\n        Parameters:\n            model_args: ArgsLike, model_kwargs: KwargsLike\n                The args and kwargs given to the call method of a model. This\n                should represent the records to obtain attributions for, assumed\n                to be a *batched* input. if `self.model` supports evaluation on\n                *data tensors*, the  appropriate tensor type may be used (e.g.,\n                Pytorch models may accept Pytorch tensors in addition to\n                `np.ndarray`s). The shape of the inputs must match the input\n                shape of `self.model`. \n\n        Returns\n            - np.ndarray when single attribution_cut input, single qoi output\n            - or ArgsLike[np.ndarray] when single input, multiple output (or\n              vice versa) \n            - or ArgsLike[ArgsLike[np.ndarray]] when multiple output (outer),\n              multiple input (inner)\n\n            An array of attributions, matching the shape and type of `from_cut`\n            of the slice. Each entry in the returned array represents the degree\n            to which the corresponding feature affected the model's outcome on\n            the corresponding point.\n\n            If attributing to a component with multiple inputs, a list for each\n            will be returned.\n\n            If the quantity of interest features multiple outputs, a list for\n            each will be returned.\n        \"\"\"\n\n        # Calls like: attributions([arg1, arg2]) will get read as model_args =\n        # ([arg1, arg2],), that is, a tuple with a single element containing the\n        # model args. Test below checks for this. TODO: Disallow such\n        # invocations? They should be given as attributions(arg1, arg2).\n        if isinstance(model_args,\n                      tuple) and len(model_args) == 1 and isinstance(\n                          model_args[0], DATA_CONTAINER_TYPE):\n            model_args = model_args[0]\n\n        model_inputs = ModelInputs(\n            args=many_of_om(model_args), kwargs=model_kwargs\n        )\n        # Will cast results to this data container type.\n        return_type = type(model_inputs.first_batchable(get_backend()))\n\n        pieces = self._attributions(model_inputs)\n\n        # Format attributions into the public structure which throws out output\n        # lists and input lists if there is only one output or only one input.\n        # Also cast to whatever the input type was.\n        attributions: Outputs[Inputs[np.ndarray]] = nested_cast(\n            backend=get_backend(), astype=return_type, args=pieces.attributions\n        )\n        attributions: Outputs[OM[Inputs, np.ndarray]\n                             ] = [om_of_many(attr) for attr in attributions]\n        attributions: OM[Outputs, OM[Inputs,\n                                     np.ndarray]] = om_of_many(attributions)\n\n        if pieces.gradients is not None or pieces.interventions is not None:\n            tru_logger.warning(\n                \"AttributionMethod configured to return gradients or interventions. \"\n                \"Use the internal _attribution call to retrieve those.\"\n            )\n\n        return attributions\n</code></pre>"},{"location":"api/attribution/#trulens.nn.attribution.AttributionMethod.model","title":"<code>model: ModelWrapper</code>  <code>property</code>","text":"<p>Model for which attributions are calculated.</p>"},{"location":"api/attribution/#trulens.nn.attribution.AttributionMethod.__init__","title":"<code>__init__(model, rebatch_size=None, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Abstract constructor.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ModelWrapper</code> <p>ModelWrapper Model for which attributions are calculated.</p> required <code>rebatch_size</code> <code>int</code> <p>int (optional) Will rebatch instances to this size if given. This may be required for GPU usage if using a DoI which produces multiple instances per user-provided instance. Many valued DoIs will expand the tensors sent to each layer to original_batch_size * doi_size. The rebatch size will break up original_batch_size * doi_size into rebatch_size chunks to send to model.</p> <code>None</code> Source code in <code>trulens/nn/attribution.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self, model: ModelWrapper, rebatch_size: int = None, *args, **kwargs\n):\n\"\"\"\n    Abstract constructor.\n\n    Parameters:\n        model: ModelWrapper\n            Model for which attributions are calculated.\n\n        rebatch_size: int (optional)\n            Will rebatch instances to this size if given. This may be\n            required for GPU usage if using a DoI which produces multiple\n            instances per user-provided instance. Many valued DoIs will\n            expand the tensors sent to each layer to original_batch_size *\n            doi_size. The rebatch size will break up original_batch_size *\n            doi_size into rebatch_size chunks to send to model.\n    \"\"\"\n    self._model = model\n\n    self.rebatch_size = rebatch_size\n</code></pre>"},{"location":"api/attribution/#trulens.nn.attribution.AttributionMethod.attributions","title":"<code>attributions(*model_args, **model_kwargs)</code>","text":"<p>Returns attributions for the given input. Attributions are in the same shape as the layer that attributions are being generated for. </p> <p>The numeric scale of the attributions will depend on the specific implementations of the Distribution of Interest and Quantity of Interest. However it is generally related to the scale of gradients on the Quantity of Interest. </p> <p>For example, Integrated Gradients uses the linear interpolation Distribution of Interest which subsumes the completeness axiom which ensures the sum of all attributions of a record equals the output determined by the Quantity of Interest on the same record. </p> <p>The Point Distribution of Interest will be determined by the gradient at a single point, thus being a good measure of model sensitivity. </p> <p>Parameters:</p> Name Type Description Default <code>model_args</code> <code>ArgsLike</code> <p>ArgsLike, model_kwargs: KwargsLike The args and kwargs given to the call method of a model. This should represent the records to obtain attributions for, assumed to be a batched input. if <code>self.model</code> supports evaluation on data tensors, the  appropriate tensor type may be used (e.g., Pytorch models may accept Pytorch tensors in addition to <code>np.ndarray</code>s). The shape of the inputs must match the input shape of <code>self.model</code>. </p> <code>()</code> <p>Returns     - np.ndarray when single attribution_cut input, single qoi output     - or ArgsLike[np.ndarray] when single input, multiple output (or       vice versa)      - or ArgsLike[ArgsLike[np.ndarray]] when multiple output (outer),       multiple input (inner)</p> <pre><code>An array of attributions, matching the shape and type of `from_cut`\nof the slice. Each entry in the returned array represents the degree\nto which the corresponding feature affected the model's outcome on\nthe corresponding point.\n\nIf attributing to a component with multiple inputs, a list for each\nwill be returned.\n\nIf the quantity of interest features multiple outputs, a list for\neach will be returned.\n</code></pre> Source code in <code>trulens/nn/attribution.py</code> <pre><code>def attributions(\n    self, *model_args: ArgsLike, **model_kwargs: KwargsLike\n) -&gt; Union[TensorLike, ArgsLike[TensorLike],\n           ArgsLike[ArgsLike[TensorLike]]]:\n\"\"\"\n    Returns attributions for the given input. Attributions are in the same\n    shape as the layer that attributions are being generated for. \n\n    The numeric scale of the attributions will depend on the specific\n    implementations of the Distribution of Interest and Quantity of\n    Interest. However it is generally related to the scale of gradients on\n    the Quantity of Interest. \n\n    For example, Integrated Gradients uses the linear interpolation\n    Distribution of Interest which subsumes the completeness axiom which\n    ensures the sum of all attributions of a record equals the output\n    determined by the Quantity of Interest on the same record. \n\n    The Point Distribution of Interest will be determined by the gradient at\n    a single point, thus being a good measure of model sensitivity. \n\n    Parameters:\n        model_args: ArgsLike, model_kwargs: KwargsLike\n            The args and kwargs given to the call method of a model. This\n            should represent the records to obtain attributions for, assumed\n            to be a *batched* input. if `self.model` supports evaluation on\n            *data tensors*, the  appropriate tensor type may be used (e.g.,\n            Pytorch models may accept Pytorch tensors in addition to\n            `np.ndarray`s). The shape of the inputs must match the input\n            shape of `self.model`. \n\n    Returns\n        - np.ndarray when single attribution_cut input, single qoi output\n        - or ArgsLike[np.ndarray] when single input, multiple output (or\n          vice versa) \n        - or ArgsLike[ArgsLike[np.ndarray]] when multiple output (outer),\n          multiple input (inner)\n\n        An array of attributions, matching the shape and type of `from_cut`\n        of the slice. Each entry in the returned array represents the degree\n        to which the corresponding feature affected the model's outcome on\n        the corresponding point.\n\n        If attributing to a component with multiple inputs, a list for each\n        will be returned.\n\n        If the quantity of interest features multiple outputs, a list for\n        each will be returned.\n    \"\"\"\n\n    # Calls like: attributions([arg1, arg2]) will get read as model_args =\n    # ([arg1, arg2],), that is, a tuple with a single element containing the\n    # model args. Test below checks for this. TODO: Disallow such\n    # invocations? They should be given as attributions(arg1, arg2).\n    if isinstance(model_args,\n                  tuple) and len(model_args) == 1 and isinstance(\n                      model_args[0], DATA_CONTAINER_TYPE):\n        model_args = model_args[0]\n\n    model_inputs = ModelInputs(\n        args=many_of_om(model_args), kwargs=model_kwargs\n    )\n    # Will cast results to this data container type.\n    return_type = type(model_inputs.first_batchable(get_backend()))\n\n    pieces = self._attributions(model_inputs)\n\n    # Format attributions into the public structure which throws out output\n    # lists and input lists if there is only one output or only one input.\n    # Also cast to whatever the input type was.\n    attributions: Outputs[Inputs[np.ndarray]] = nested_cast(\n        backend=get_backend(), astype=return_type, args=pieces.attributions\n    )\n    attributions: Outputs[OM[Inputs, np.ndarray]\n                         ] = [om_of_many(attr) for attr in attributions]\n    attributions: OM[Outputs, OM[Inputs,\n                                 np.ndarray]] = om_of_many(attributions)\n\n    if pieces.gradients is not None or pieces.interventions is not None:\n        tru_logger.warning(\n            \"AttributionMethod configured to return gradients or interventions. \"\n            \"Use the internal _attribution call to retrieve those.\"\n        )\n\n    return attributions\n</code></pre>"},{"location":"api/attribution/#trulens.nn.attribution.AttributionResult","title":"<code>AttributionResult</code>  <code>dataclass</code>","text":"<p>_attribution method output container.</p> Source code in <code>trulens/nn/attribution.py</code> <pre><code>@dataclass\nclass AttributionResult:\n\"\"\"\n    _attribution method output container.\n    \"\"\"\n\n    attributions: Outputs[Inputs[TensorLike]] = None\n    gradients: Outputs[Inputs[Uniform[TensorLike]]] = None\n    interventions: Inputs[Uniform[TensorLike]] = None\n</code></pre>"},{"location":"api/attribution/#trulens.nn.attribution.InputAttribution","title":"<code>InputAttribution</code>","text":"<p>         Bases: <code>InternalInfluence</code></p> <p>Attributions of input features on either internal or output quantities. This is essentially an alias for</p> <pre><code>InternalInfluence(\n    model,\n    (trulens.nn.slices.InputCut(), cut),\n    qoi,\n    doi,\n    multiply_activation)\n</code></pre> Source code in <code>trulens/nn/attribution.py</code> <pre><code>class InputAttribution(InternalInfluence):\n\"\"\"\n    Attributions of input features on either internal or output quantities. This\n    is essentially an alias for\n\n    ```python\n    InternalInfluence(\n        model,\n        (trulens.nn.slices.InputCut(), cut),\n        qoi,\n        doi,\n        multiply_activation)\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        model: ModelWrapper,\n        qoi_cut: CutLike = None,  # see WARNING-LOAD-INIT\n        qoi: QoiLike = 'max',\n        doi_cut: CutLike = None,  # see WARNING-LOAD-INIT\n        doi: DoiLike = 'point',\n        multiply_activation: bool = True,\n        *args,\n        **kwargs\n    ):\n\"\"\"\n        Parameters:\n            model :\n                Model for which attributions are calculated.\n\n            qoi_cut :\n                The cut determining the layer from which the QoI is derived.\n                Expects a `Cut` object, or a related type that can be\n                interpreted as a `Cut`, as documented below.\n\n                If an `int` is given, it represents the index of a layer in\n                `model`. \n\n                If a `str` is given, it represents the name of a layer in\n                `model`. \n\n                `None` is an alternative for `slices.OutputCut()`.\n\n            qoi : quantities.QoI | int | tuple | str\n                Quantity of interest to attribute. Expects a `QoI` object, or a\n                related type that can be interpreted as a `QoI`, as documented\n                below.\n\n                If an `int` is given, the quantity of interest is taken to be\n                the slice output for the class/neuron/channel specified by the\n                given integer, i.e., ```python\n                quantities.InternalChannelQoI(qoi) ```\n\n                If a tuple or list of two integers is given, then the quantity\n                of interest is taken to be the comparative quantity for the\n                class given by the first integer against the class given by the\n                second integer, i.e., ```python quantities.ComparativeQoI(*qoi)\n                ```\n\n                If a callable is given, it is interpreted as a function\n                representing the QoI, i.e., ```python quantities.LambdaQoI(qoi)\n                ```\n\n                If the string, `'max'`, is given, the quantity of interest is\n                taken to be the output for the class with the maximum score,\n                i.e., ```python quantities.MaxClassQoI() ```\n\n            doi_cut :\n                For models which have non-differentiable pre-processing at the\n                start of the model, specify the cut of the initial\n                differentiable input form. For NLP models, for example, this\n                could point to the embedding layer. If not provided, InputCut is\n                assumed.\n\n            doi : distributions.DoI | str\n                Distribution of interest over inputs. Expects a `DoI` object, or\n                a related type that can be interpreted as a `DoI`, as documented\n                below.\n\n                If the string, `'point'`, is given, the distribution is taken to\n                be the single point passed to `attributions`, i.e., ```python\n                distributions.PointDoi() ```\n\n                If the string, `'linear'`, is given, the distribution is taken\n                to be the linear interpolation from the zero input to the point\n                passed to `attributions`, i.e., ```python\n                distributions.LinearDoi() ```\n\n            multiply_activation : bool, optional\n                Whether to multiply the gradient result by its corresponding\n                activation, thus converting from \"*influence space*\" to\n                \"*attribution space*.\"\n        \"\"\"\n        if doi_cut is None:\n            # WARNING-LOAD-INIT: Do not put this as a default arg in the def\n            # line. That would cause an instantiation of InputCut when this\n            # class is loaded and before it is used. Because get_backend gets\n            # called in Cut.__init__, it may fail if this class is loaded before\n            # trulens.nn.models.get_model_wrapper is called on some model.\n            doi_cut = InputCut()\n\n        super().__init__(\n            model, (doi_cut, qoi_cut),\n            qoi,\n            doi,\n            multiply_activation=multiply_activation,\n            *args,\n            **kwargs\n        )\n</code></pre>"},{"location":"api/attribution/#trulens.nn.attribution.InputAttribution.__init__","title":"<code>__init__(model, qoi_cut=None, qoi='max', doi_cut=None, doi='point', multiply_activation=True, *args, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <p>Model for which attributions are calculated.</p> required <code>qoi_cut</code> <p>The cut determining the layer from which the QoI is derived. Expects a <code>Cut</code> object, or a related type that can be interpreted as a <code>Cut</code>, as documented below.</p> <p>If an <code>int</code> is given, it represents the index of a layer in <code>model</code>. </p> <p>If a <code>str</code> is given, it represents the name of a layer in <code>model</code>. </p> <p><code>None</code> is an alternative for <code>slices.OutputCut()</code>.</p> <code>None</code> <code>qoi</code> <p>quantities.QoI | int | tuple | str Quantity of interest to attribute. Expects a <code>QoI</code> object, or a related type that can be interpreted as a <code>QoI</code>, as documented below.</p> <p>If an <code>int</code> is given, the quantity of interest is taken to be the slice output for the class/neuron/channel specified by the given integer, i.e., <code>python quantities.InternalChannelQoI(qoi)</code></p> <p>If a tuple or list of two integers is given, then the quantity of interest is taken to be the comparative quantity for the class given by the first integer against the class given by the second integer, i.e., ```python quantities.ComparativeQoI(*qoi) <pre><code>If a callable is given, it is interpreted as a function\nrepresenting the QoI, i.e., ```python quantities.LambdaQoI(qoi)\n</code></pre></p> <p>If the string, <code>'max'</code>, is given, the quantity of interest is taken to be the output for the class with the maximum score, i.e., <code>python quantities.MaxClassQoI()</code></p> <code>'max'</code> <code>doi_cut</code> <p>For models which have non-differentiable pre-processing at the start of the model, specify the cut of the initial differentiable input form. For NLP models, for example, this could point to the embedding layer. If not provided, InputCut is assumed.</p> <code>None</code> <code>doi</code> <p>distributions.DoI | str Distribution of interest over inputs. Expects a <code>DoI</code> object, or a related type that can be interpreted as a <code>DoI</code>, as documented below.</p> <p>If the string, <code>'point'</code>, is given, the distribution is taken to be the single point passed to <code>attributions</code>, i.e., <code>python distributions.PointDoi()</code></p> <p>If the string, <code>'linear'</code>, is given, the distribution is taken to be the linear interpolation from the zero input to the point passed to <code>attributions</code>, i.e., <code>python distributions.LinearDoi()</code></p> <code>'point'</code> <code>multiply_activation</code> <p>bool, optional Whether to multiply the gradient result by its corresponding activation, thus converting from \"influence space\" to \"attribution space.\"</p> <code>True</code> Source code in <code>trulens/nn/attribution.py</code> <pre><code>def __init__(\n    self,\n    model: ModelWrapper,\n    qoi_cut: CutLike = None,  # see WARNING-LOAD-INIT\n    qoi: QoiLike = 'max',\n    doi_cut: CutLike = None,  # see WARNING-LOAD-INIT\n    doi: DoiLike = 'point',\n    multiply_activation: bool = True,\n    *args,\n    **kwargs\n):\n\"\"\"\n    Parameters:\n        model :\n            Model for which attributions are calculated.\n\n        qoi_cut :\n            The cut determining the layer from which the QoI is derived.\n            Expects a `Cut` object, or a related type that can be\n            interpreted as a `Cut`, as documented below.\n\n            If an `int` is given, it represents the index of a layer in\n            `model`. \n\n            If a `str` is given, it represents the name of a layer in\n            `model`. \n\n            `None` is an alternative for `slices.OutputCut()`.\n\n        qoi : quantities.QoI | int | tuple | str\n            Quantity of interest to attribute. Expects a `QoI` object, or a\n            related type that can be interpreted as a `QoI`, as documented\n            below.\n\n            If an `int` is given, the quantity of interest is taken to be\n            the slice output for the class/neuron/channel specified by the\n            given integer, i.e., ```python\n            quantities.InternalChannelQoI(qoi) ```\n\n            If a tuple or list of two integers is given, then the quantity\n            of interest is taken to be the comparative quantity for the\n            class given by the first integer against the class given by the\n            second integer, i.e., ```python quantities.ComparativeQoI(*qoi)\n            ```\n\n            If a callable is given, it is interpreted as a function\n            representing the QoI, i.e., ```python quantities.LambdaQoI(qoi)\n            ```\n\n            If the string, `'max'`, is given, the quantity of interest is\n            taken to be the output for the class with the maximum score,\n            i.e., ```python quantities.MaxClassQoI() ```\n\n        doi_cut :\n            For models which have non-differentiable pre-processing at the\n            start of the model, specify the cut of the initial\n            differentiable input form. For NLP models, for example, this\n            could point to the embedding layer. If not provided, InputCut is\n            assumed.\n\n        doi : distributions.DoI | str\n            Distribution of interest over inputs. Expects a `DoI` object, or\n            a related type that can be interpreted as a `DoI`, as documented\n            below.\n\n            If the string, `'point'`, is given, the distribution is taken to\n            be the single point passed to `attributions`, i.e., ```python\n            distributions.PointDoi() ```\n\n            If the string, `'linear'`, is given, the distribution is taken\n            to be the linear interpolation from the zero input to the point\n            passed to `attributions`, i.e., ```python\n            distributions.LinearDoi() ```\n\n        multiply_activation : bool, optional\n            Whether to multiply the gradient result by its corresponding\n            activation, thus converting from \"*influence space*\" to\n            \"*attribution space*.\"\n    \"\"\"\n    if doi_cut is None:\n        # WARNING-LOAD-INIT: Do not put this as a default arg in the def\n        # line. That would cause an instantiation of InputCut when this\n        # class is loaded and before it is used. Because get_backend gets\n        # called in Cut.__init__, it may fail if this class is loaded before\n        # trulens.nn.models.get_model_wrapper is called on some model.\n        doi_cut = InputCut()\n\n    super().__init__(\n        model, (doi_cut, qoi_cut),\n        qoi,\n        doi,\n        multiply_activation=multiply_activation,\n        *args,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/attribution/#trulens.nn.attribution.IntegratedGradients","title":"<code>IntegratedGradients</code>","text":"<p>         Bases: <code>InputAttribution</code></p> <p>Implementation for the Integrated Gradients method from the following paper:</p> <p>Axiomatic Attribution for Deep Networks</p> <p>This should be cited using:</p> <pre><code>@INPROCEEDINGS{\nsundararajan17axiomatic,\nauthor={Mukund Sundararajan and Ankur Taly, and Qiqi Yan},\ntitle={Axiomatic Attribution for Deep Networks},\nbooktitle={International Conference on Machine Learning (ICML)},\nyear={2017},\n}\n</code></pre> <p>This is essentially an alias for</p> <pre><code>InternalInfluence(\n    model,\n    (trulens.nn.slices.InputCut(), trulens.nn.slices.OutputCut()),\n    'max',\n    trulens.nn.distributions.LinearDoi(baseline, resolution),\n    multiply_activation=True)\n</code></pre> Source code in <code>trulens/nn/attribution.py</code> <pre><code>class IntegratedGradients(InputAttribution):\n\"\"\"\n    Implementation for the Integrated Gradients method from the following paper:\n\n    [Axiomatic Attribution for Deep Networks](\n        https://arxiv.org/pdf/1703.01365)\n\n    This should be cited using:\n\n    ```bibtex\n    @INPROCEEDINGS{\n        sundararajan17axiomatic,\n        author={Mukund Sundararajan and Ankur Taly, and Qiqi Yan},\n        title={Axiomatic Attribution for Deep Networks},\n        booktitle={International Conference on Machine Learning (ICML)},\n        year={2017},\n    }\n    ```\n\n    This is essentially an alias for\n\n    ```python\n    InternalInfluence(\n        model,\n        (trulens.nn.slices.InputCut(), trulens.nn.slices.OutputCut()),\n        'max',\n        trulens.nn.distributions.LinearDoi(baseline, resolution),\n        multiply_activation=True)\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        model: ModelWrapper,\n        baseline=None,\n        resolution: int = 50,\n        doi_cut=None,  # see WARNING-LOAD-INIT\n        qoi='max',\n        qoi_cut=None,  # see WARNING-LOAD-INIT\n        *args,\n        **kwargs\n    ):\n\"\"\"\n        Parameters:\n            model:\n                Model for which attributions are calculated.\n\n            baseline:\n                The baseline to interpolate from. Must be same shape as the \n                input. If `None` is given, the zero vector in the appropriate \n                shape will be used.\n\n            resolution:\n                Number of points to use in the approximation. A higher \n                resolution is more computationally expensive, but gives a better\n                approximation of the mathematical formula this attribution \n                method represents.\n        \"\"\"\n\n        if doi_cut is None:\n            doi_cut = InputCut()\n\n        if qoi_cut is None:\n            qoi_cut = OutputCut()\n\n        super().__init__(\n            model=model,\n            qoi_cut=qoi_cut,\n            qoi=qoi,\n            doi_cut=doi_cut,\n            doi=LinearDoi(baseline, resolution, cut=doi_cut),\n            multiply_activation=True,\n            *args,\n            **kwargs\n        )\n</code></pre>"},{"location":"api/attribution/#trulens.nn.attribution.IntegratedGradients.__init__","title":"<code>__init__(model, baseline=None, resolution=50, doi_cut=None, qoi='max', qoi_cut=None, *args, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>ModelWrapper</code> <p>Model for which attributions are calculated.</p> required <code>baseline</code> <p>The baseline to interpolate from. Must be same shape as the  input. If <code>None</code> is given, the zero vector in the appropriate  shape will be used.</p> <code>None</code> <code>resolution</code> <code>int</code> <p>Number of points to use in the approximation. A higher  resolution is more computationally expensive, but gives a better approximation of the mathematical formula this attribution  method represents.</p> <code>50</code> Source code in <code>trulens/nn/attribution.py</code> <pre><code>def __init__(\n    self,\n    model: ModelWrapper,\n    baseline=None,\n    resolution: int = 50,\n    doi_cut=None,  # see WARNING-LOAD-INIT\n    qoi='max',\n    qoi_cut=None,  # see WARNING-LOAD-INIT\n    *args,\n    **kwargs\n):\n\"\"\"\n    Parameters:\n        model:\n            Model for which attributions are calculated.\n\n        baseline:\n            The baseline to interpolate from. Must be same shape as the \n            input. If `None` is given, the zero vector in the appropriate \n            shape will be used.\n\n        resolution:\n            Number of points to use in the approximation. A higher \n            resolution is more computationally expensive, but gives a better\n            approximation of the mathematical formula this attribution \n            method represents.\n    \"\"\"\n\n    if doi_cut is None:\n        doi_cut = InputCut()\n\n    if qoi_cut is None:\n        qoi_cut = OutputCut()\n\n    super().__init__(\n        model=model,\n        qoi_cut=qoi_cut,\n        qoi=qoi,\n        doi_cut=doi_cut,\n        doi=LinearDoi(baseline, resolution, cut=doi_cut),\n        multiply_activation=True,\n        *args,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/attribution/#trulens.nn.attribution.InternalInfluence","title":"<code>InternalInfluence</code>","text":"<p>         Bases: <code>AttributionMethod</code></p> <p>Internal attributions parameterized by a slice, quantity of interest, and distribution of interest.</p> <p>The slice specifies the layers at which the internals of the model are to be exposed; it is represented by two cuts, which specify the layer the attributions are assigned to and the layer from which the quantity of interest is derived. The Quantity of Interest (QoI) is a function of the output specified by the slice that determines the network output behavior that the attributions are to describe. The Distribution of Interest (DoI) specifies the records over which the attributions are aggregated.</p> <p>More information can be found in the following paper:</p> <p>Influence-Directed Explanations for Deep Convolutional Networks</p> <p>This should be cited using:</p> <pre><code>@INPROCEEDINGS{\nleino18influence,\nauthor={\n        Klas Leino and\n        Shayak Sen and\n        Anupam Datta and\n        Matt Fredrikson and\n        Linyi Li},\ntitle={\n        Influence-Directed Explanations\n        for Deep Convolutional Networks},\nbooktitle={IEEE International Test Conference (ITC)},\nyear={2018},\n}\n</code></pre> Source code in <code>trulens/nn/attribution.py</code> <pre><code>class InternalInfluence(AttributionMethod):\n\"\"\"Internal attributions parameterized by a slice, quantity of interest, and\n    distribution of interest.\n\n    The *slice* specifies the layers at which the internals of the model are to\n    be exposed; it is represented by two *cuts*, which specify the layer the\n    attributions are assigned to and the layer from which the quantity of\n    interest is derived. The *Quantity of Interest* (QoI) is a function of the\n    output specified by the slice that determines the network output behavior\n    that the attributions are to describe. The *Distribution of Interest* (DoI)\n    specifies the records over which the attributions are aggregated.\n\n    More information can be found in the following paper:\n\n    [Influence-Directed Explanations for Deep Convolutional Networks](\n        https://arxiv.org/pdf/1802.03788.pdf)\n\n    This should be cited using:\n\n    ```bibtex\n    @INPROCEEDINGS{\n        leino18influence,\n        author={\n            Klas Leino and\n            Shayak Sen and\n            Anupam Datta and\n            Matt Fredrikson and\n            Linyi Li},\n        title={\n            Influence-Directed Explanations\n            for Deep Convolutional Networks},\n        booktitle={IEEE International Test Conference (ITC)},\n        year={2018},\n    }\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        model: ModelWrapper,\n        cuts: SliceLike,\n        qoi: QoiLike,\n        doi: DoiLike,\n        multiply_activation: bool = True,\n        return_grads: bool = False,\n        return_doi: bool = False,\n        *args,\n        **kwargs\n    ):\n\"\"\"\n        Parameters:\n            model:\n                Model for which attributions are calculated.\n\n            cuts: \n                The slice to use when computing the attributions. The slice \n                keeps track of the layer whose output attributions are \n                calculated and the layer for which the quantity of interest is \n                computed. Expects a `Slice` object, or a related type that can\n                be interpreted as a `Slice`, as documented below.\n\n                If a single `Cut` object is given, it is assumed to be the cut \n                representing the layer for which attributions are calculated \n                (i.e., `from_cut` in `Slice`) and the layer for the quantity of \n                interest (i.e., `to_cut` in `slices.Slice`) is taken to be the \n                output of the network. If a tuple or list of two `Cut`s is \n                given, they are assumed to be `from_cut` and `to_cut`, \n                respectively.\n\n                A cut (or the cuts within the tuple) can also be represented as \n                an `int`, `str`, or `None`. If an `int` is given, it represents \n                the index of a layer in `model`. If a `str` is given, it \n                represents the name of a layer in `model`. `None` is an \n                alternative for `slices.InputCut`.\n\n            qoi:\n                Quantity of interest to attribute. Expects a `QoI` object, or a\n                related type that can be interpreted as a `QoI`, as documented\n                below.\n\n                If an `int` is given, the quantity of interest is taken to be \n                the slice output for the class/neuron/channel specified by the \n                given integer, i.e., \n                ```python\n                quantities.InternalChannelQoI(qoi)\n                ```\n\n                If a tuple or list of two integers is given, then the quantity \n                of interest is taken to be the comparative quantity for the \n                class given by the first integer against the class given by the \n                second integer, i.e., \n                ```python\n                quantities.ComparativeQoI(*qoi)\n                ```\n\n                If a callable is given, it is interpreted as a function\n                representing the QoI, i.e.,\n                ```python\n                quantities.LambdaQoI(qoi)\n                ```\n\n                If the string, `'max'`, is given, the quantity of interest is \n                taken to be the output for the class with the maximum score, \n                i.e., \n                ```python\n                quantities.MaxClassQoI()\n                ```\n\n            doi:\n                Distribution of interest over inputs. Expects a `DoI` object, or\n                a related type that can be interpreted as a `DoI`, as documented\n                below.\n\n                If the string, `'point'`, is given, the distribution is taken to\n                be the single point passed to `attributions`, i.e., \n                ```python\n                distributions.PointDoi()\n                ```\n\n                If the string, `'linear'`, is given, the distribution is taken \n                to be the linear interpolation from the zero input to the point \n                passed to `attributions`, i.e., \n                ```python\n                distributions.LinearDoi()\n                ```\n\n            multiply_activation:\n                Whether to multiply the gradient result by its corresponding\n                activation, thus converting from \"*influence space*\" to \n                \"*attribution space*.\"\n        \"\"\"\n        super().__init__(model, *args, **kwargs)\n\n        self.slice = InternalInfluence.__get_slice(cuts)\n        self.qoi = InternalInfluence.__get_qoi(qoi)\n        self.doi = InternalInfluence.__get_doi(doi, cut=self.slice.from_cut)\n        self._do_multiply = multiply_activation\n        self._return_grads = return_grads\n        self._return_doi = return_doi\n\n    def _attributions(self, model_inputs: ModelInputs) -&gt; AttributionResult:\n        # NOTE: not symbolic\n\n        B = get_backend()\n        results = AttributionResult()\n\n        # Create a message for out-of-memory errors regarding float and batch size.\n        first_batchable = model_inputs.first_batchable(B)\n        if first_batchable is None:\n            batch_size = 1\n        else:\n            batch_size = first_batchable.shape[0]\n\n        param_msgs = [\n            f\"float size = {B.floatX_size} ({B.floatX}); consider changing to a smaller type.\",\n            f\"batch size = {batch_size}; consider reducing the size of the batch you send to the attributions method.\"\n        ]\n\n        doi_cut = self.doi.cut() if self.doi.cut() else InputCut()\n\n        with memory_suggestions(*param_msgs):  # Handles out-of-memory messages.\n            doi_val: List[B.Tensor] = self.model._fprop(\n                model_inputs=model_inputs,\n                to_cut=doi_cut,\n                doi_cut=InputCut(),\n                attribution_cut=None,  # InputCut(),\n                intervention=model_inputs\n            )[0]\n\n        doi_val = nested_map(doi_val, B.as_array)\n\n        D = self.doi._wrap_public_call(doi_val, model_inputs=model_inputs)\n\n        if self._return_doi:\n            results.interventions = D  # : Inputs[Uniform[TensorLike]]\n\n        D_tensors = D[0]\n        n_doi = len(D_tensors)\n        if isinstance(D_tensors, MAP_CONTAINER_TYPE):\n            for k in D_tensors.keys():\n                if isinstance(D_tensors[k], DATA_CONTAINER_TYPE):\n                    n_doi = len(D_tensors[k])\n        D = self.__concatenate_doi(D)\n        rebatch_size = self.rebatch_size\n        if rebatch_size is None:\n            rebatch_size = len(D[0])\n\n        intervention = TensorArgs(args=D)\n        model_inputs_expanded = tile(what=model_inputs, onto=intervention)\n        # Create a message for out-of-memory errors regarding doi_size.\n        # TODO: Generalize this message to doi other than LinearDoI:\n        doi_size_msg = f\"distribution of interest size = {n_doi}; consider reducing intervention resolution.\"\n\n        combined_batch_size = n_doi * batch_size\n        combined_batch_msg = f\"combined batch size = {combined_batch_size}; consider reducing batch size, intervention size\"\n\n        rebatch_size_msg = f\"rebatch_size = {rebatch_size}; consider reducing this AttributionMethod constructor parameter (default is same as combined batch size).\"\n\n        # Calculate the gradient of each of the points in the DoI.\n        with memory_suggestions(\n                param_msgs +\n            [doi_size_msg, combined_batch_msg, rebatch_size_msg]\n        ):  # Handles out-of-memory messages.\n            qoi_grads_expanded: List[Outputs[Inputs[TensorLike]]] = []\n\n            for inputs_batch, intervention_batch in rebatch(\n                    model_inputs_expanded, intervention,\n                    batch_size=rebatch_size):\n\n                qoi_grads_expanded_batch: Outputs[\n                    Inputs[TensorLike]] = self.model._qoi_bprop(\n                        qoi=self.qoi,\n                        model_inputs=inputs_batch,\n                        attribution_cut=self.slice.from_cut,\n                        to_cut=self.slice.to_cut,\n                        intervention=intervention_batch,\n                        doi_cut=doi_cut\n                    )\n\n                # important to cast to numpy inside loop:\n                qoi_grads_expanded.append(\n                    nested_map(qoi_grads_expanded_batch, B.as_array)\n                )\n\n        num_outputs = len(qoi_grads_expanded[0])\n        num_inputs = len(qoi_grads_expanded[0][0])\n        transpose = [\n            [[] for _ in range(num_inputs)] for _ in range(num_outputs)\n        ]\n        for o in range(num_outputs):\n            for i in range(num_inputs):\n                for qoi_grads_batch in qoi_grads_expanded:\n                    transpose[o][i].append(qoi_grads_batch[o][i])\n\n        def container_concat(x):\n\"\"\"Applies np concatenate on a container. If it is a map type, it will apply it on each key.\n\n            Args:\n                x (map or data container): A container of tensors\n\n            Returns:\n                concatenated tensors of the container.\n            \"\"\"\n            if isinstance(x[0], MAP_CONTAINER_TYPE):\n                ret_map = {}\n                for k in x[0].keys():\n                    ret_map[k] = np.concatenate([_dict[k] for _dict in x])\n                return ret_map\n            else:\n                return np.concatenate(x)\n\n        qoi_grads_expanded: Outputs[Inputs[np.ndarray]] = nested_map(\n            transpose, container_concat, nest=2\n        )\n        qoi_grads_expanded: Outputs[Inputs[np.ndarray]] = nested_map(\n            qoi_grads_expanded,\n            lambda grad: np.reshape(grad, (n_doi, -1) + grad.shape[1:]),\n            nest=2\n        )\n        if self._return_grads:\n            results.gradients = qoi_grads_expanded  # : Outputs[Inputs[Uniform[TensorLike]]]\n\n        # TODO: Does this need to be done in numpy?\n        attrs: Outputs[Inputs[TensorLike]] = nested_map(\n            qoi_grads_expanded, lambda grad: np.mean(grad, axis=0), nest=2\n        )\n\n        # Multiply by the activation multiplier if specified.\n        if self._do_multiply:\n            with memory_suggestions(param_msgs):\n                z_val = self.model._fprop(\n                    model_inputs=model_inputs,\n                    doi_cut=InputCut(),\n                    attribution_cut=None,\n                    to_cut=self.slice.from_cut,\n                    intervention=model_inputs  # intentional\n                )[0]\n\n            mults: Inputs[TensorLike\n                         ] = self.doi._wrap_public_get_activation_multiplier(\n                             z_val, model_inputs=model_inputs\n                         )\n            mults: Inputs[np.ndarray] = nested_cast(\n                backend=B, args=mults, astype=np.ndarray\n            )\n            mult_attrs = []\n            for attr in attrs:  # Outputs\n\n                zipped = nested_zip(attr, mults)\n\n                def zip_mult(zipped_attr_mults):\n                    attr = zipped_attr_mults[0]\n                    mults = zipped_attr_mults[1]\n                    return attr * mults\n\n                attr = nested_map(\n                    zipped, zip_mult, check_accessor=lambda x: x[0]\n                )\n                mult_attrs.append(attr)\n            attrs = mult_attrs\n        results.attributions = attrs  # : Outputs[Inputs[TensorLike]]\n\n        return results\n\n    @staticmethod\n    def __get_qoi(qoi_arg):\n\"\"\"\n        Helper function to get a `QoI` object from more user-friendly primitive \n        arguments.\n        \"\"\"\n        # TODO(klas): we could potentially do some basic error catching here,\n        #   for example, making sure the index for a given channel is in range.\n\n        if isinstance(qoi_arg, QoI):\n            # We were already given a QoI, so return it.\n            return qoi_arg\n\n        elif callable(qoi_arg):\n            # If we were given a callable, treat that function as a QoI.\n            return LambdaQoI(qoi_arg)\n\n        elif isinstance(qoi_arg, int):\n            # If we receive an int, we take it to be the class/channel index\n            # (whether it's a class or channel depends on the layer the quantity\n            # is for, but `InternalChannelQoI` generalizes to both).\n            return InternalChannelQoI(qoi_arg)\n\n        elif isinstance(qoi_arg, DATA_CONTAINER_TYPE):\n            # If we receive a DATA_CONTAINER_TYPE, we take it to be two classes\n            # for which we are performing a comparative quantity of interest.\n            if len(qoi_arg) == 2:\n                return ComparativeQoI(*qoi_arg)\n\n            else:\n                raise ValueError(\n                    'Tuple or list argument for `qoi` must have length 2'\n                )\n\n        elif isinstance(qoi_arg, str):\n            # We can specify `MaxClassQoI` via the string 'max'.\n            if qoi_arg == 'max':\n                return MaxClassQoI()\n\n            else:\n                raise ValueError(\n                    'String argument for `qoi` must be one of the following:\\n'\n                    '  - \"max\"'\n                )\n\n        else:\n            raise ValueError('Unrecognized argument type for `qoi`')\n\n    @staticmethod\n    def __get_doi(doi_arg, cut=None):\n\"\"\"\n        Helper function to get a `DoI` object from more user-friendly primitive \n        arguments.\n        \"\"\"\n        if isinstance(doi_arg, DoI):\n            # We were already given a DoI, so return it.\n            return doi_arg\n\n        elif isinstance(doi_arg, str):\n            # We can specify `PointDoi` via the string 'point', or `LinearDoi`\n            # via the string 'linear'.\n            if doi_arg == 'point':\n                return PointDoi(cut=cut)\n\n            elif doi_arg == 'linear':\n                return LinearDoi(cut=cut)\n\n            else:\n                raise ValueError(\n                    'String argument for `doi` must be one of the following:\\n'\n                    '  - \"point\"\\n'\n                    '  - \"linear\"'\n                )\n\n        else:\n            raise ValueError('Unrecognized argument type for `doi`')\n\n    @staticmethod\n    def __get_slice(slice_arg):\n\"\"\"\n        Helper function to get a `Slice` object from more user-friendly\n        primitive arguments.\n        \"\"\"\n        if isinstance(slice_arg, Slice):\n            # We are already given a Slice, so return it.\n            return slice_arg\n\n        elif (isinstance(slice_arg, Cut) or isinstance(slice_arg, int) or\n              isinstance(slice_arg, str) or slice_arg is None or\n              slice_arg == 0):\n\n            # If we receive a Cut, we take it to be the Cut of the start layer.\n            return Slice(InternalInfluence.__get_cut(slice_arg), OutputCut())\n\n        elif isinstance(slice_arg, DATA_CONTAINER_TYPE):\n            # If we receive a DATA_CONTAINER_TYPE, we take it to be the start\n            # and end layer of the slice.\n            if len(slice_arg) == 2:\n                if slice_arg[1] is None:\n                    return Slice(\n                        InternalInfluence.__get_cut(slice_arg[0]), OutputCut()\n                    )\n                else:\n                    return Slice(\n                        InternalInfluence.__get_cut(slice_arg[0]),\n                        InternalInfluence.__get_cut(slice_arg[1])\n                    )\n\n            else:\n                raise ValueError(\n                    'Tuple or list argument for `cuts` must have length 2'\n                )\n\n        else:\n            raise ValueError('Unrecognized argument type for `cuts`')\n\n    @staticmethod\n    def __get_cut(cut_arg):\n\"\"\"\n        Helper function to get a `Cut` object from more user-friendly primitive\n        arguments.\n        \"\"\"\n        if isinstance(cut_arg, Cut):\n            # We are already given a Cut, so return it.\n            return cut_arg\n\n        elif cut_arg is None or cut_arg == 0:\n            # If we receive None or zero, we take it to be the input cut.\n            return InputCut()\n\n        # TODO(klas): may want a bit more validation here.\n        elif isinstance(cut_arg, int) or isinstance(cut_arg, str):\n            return Cut(cut_arg)\n\n        else:\n            raise ValueError('Unrecognized argument type for cut')\n\n    @staticmethod\n    def __concatenate_doi(D: Inputs[Uniform[TensorLike]]) -&gt; Inputs[TensorLike]:\n        # Returns one TensorLike for each model input.\n        if len(D[0]) == 0:\n            raise ValueError(\n                'Got empty distribution of interest. `DoI` must return at '\n                'least one point.'\n            )\n        # TODO: should this always be done in numpy or can we do it in backend?\n        D = nested_cast(backend=get_backend(), args=D, astype=np.ndarray)\n        ret = nested_map(D, np.concatenate, nest=1)\n        return ret\n</code></pre>"},{"location":"api/attribution/#trulens.nn.attribution.InternalInfluence.__init__","title":"<code>__init__(model, cuts, qoi, doi, multiply_activation=True, return_grads=False, return_doi=False, *args, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>ModelWrapper</code> <p>Model for which attributions are calculated.</p> required <code>cuts</code> <code>SliceLike</code> <p>The slice to use when computing the attributions. The slice  keeps track of the layer whose output attributions are  calculated and the layer for which the quantity of interest is  computed. Expects a <code>Slice</code> object, or a related type that can be interpreted as a <code>Slice</code>, as documented below.</p> <p>If a single <code>Cut</code> object is given, it is assumed to be the cut  representing the layer for which attributions are calculated  (i.e., <code>from_cut</code> in <code>Slice</code>) and the layer for the quantity of  interest (i.e., <code>to_cut</code> in <code>slices.Slice</code>) is taken to be the  output of the network. If a tuple or list of two <code>Cut</code>s is  given, they are assumed to be <code>from_cut</code> and <code>to_cut</code>,  respectively.</p> <p>A cut (or the cuts within the tuple) can also be represented as  an <code>int</code>, <code>str</code>, or <code>None</code>. If an <code>int</code> is given, it represents  the index of a layer in <code>model</code>. If a <code>str</code> is given, it  represents the name of a layer in <code>model</code>. <code>None</code> is an  alternative for <code>slices.InputCut</code>.</p> required <code>qoi</code> <code>QoiLike</code> <p>Quantity of interest to attribute. Expects a <code>QoI</code> object, or a related type that can be interpreted as a <code>QoI</code>, as documented below.</p> <p>If an <code>int</code> is given, the quantity of interest is taken to be  the slice output for the class/neuron/channel specified by the  given integer, i.e.,  <pre><code>quantities.InternalChannelQoI(qoi)\n</code></pre></p> <p>If a tuple or list of two integers is given, then the quantity  of interest is taken to be the comparative quantity for the  class given by the first integer against the class given by the  second integer, i.e.,  <pre><code>quantities.ComparativeQoI(*qoi)\n</code></pre></p> <p>If a callable is given, it is interpreted as a function representing the QoI, i.e., <pre><code>quantities.LambdaQoI(qoi)\n</code></pre></p> <p>If the string, <code>'max'</code>, is given, the quantity of interest is  taken to be the output for the class with the maximum score,  i.e.,  <pre><code>quantities.MaxClassQoI()\n</code></pre></p> required <code>doi</code> <code>DoiLike</code> <p>Distribution of interest over inputs. Expects a <code>DoI</code> object, or a related type that can be interpreted as a <code>DoI</code>, as documented below.</p> <p>If the string, <code>'point'</code>, is given, the distribution is taken to be the single point passed to <code>attributions</code>, i.e.,  <pre><code>distributions.PointDoi()\n</code></pre></p> <p>If the string, <code>'linear'</code>, is given, the distribution is taken  to be the linear interpolation from the zero input to the point  passed to <code>attributions</code>, i.e.,  <pre><code>distributions.LinearDoi()\n</code></pre></p> required <code>multiply_activation</code> <code>bool</code> <p>Whether to multiply the gradient result by its corresponding activation, thus converting from \"influence space\" to  \"attribution space.\"</p> <code>True</code> Source code in <code>trulens/nn/attribution.py</code> <pre><code>def __init__(\n    self,\n    model: ModelWrapper,\n    cuts: SliceLike,\n    qoi: QoiLike,\n    doi: DoiLike,\n    multiply_activation: bool = True,\n    return_grads: bool = False,\n    return_doi: bool = False,\n    *args,\n    **kwargs\n):\n\"\"\"\n    Parameters:\n        model:\n            Model for which attributions are calculated.\n\n        cuts: \n            The slice to use when computing the attributions. The slice \n            keeps track of the layer whose output attributions are \n            calculated and the layer for which the quantity of interest is \n            computed. Expects a `Slice` object, or a related type that can\n            be interpreted as a `Slice`, as documented below.\n\n            If a single `Cut` object is given, it is assumed to be the cut \n            representing the layer for which attributions are calculated \n            (i.e., `from_cut` in `Slice`) and the layer for the quantity of \n            interest (i.e., `to_cut` in `slices.Slice`) is taken to be the \n            output of the network. If a tuple or list of two `Cut`s is \n            given, they are assumed to be `from_cut` and `to_cut`, \n            respectively.\n\n            A cut (or the cuts within the tuple) can also be represented as \n            an `int`, `str`, or `None`. If an `int` is given, it represents \n            the index of a layer in `model`. If a `str` is given, it \n            represents the name of a layer in `model`. `None` is an \n            alternative for `slices.InputCut`.\n\n        qoi:\n            Quantity of interest to attribute. Expects a `QoI` object, or a\n            related type that can be interpreted as a `QoI`, as documented\n            below.\n\n            If an `int` is given, the quantity of interest is taken to be \n            the slice output for the class/neuron/channel specified by the \n            given integer, i.e., \n            ```python\n            quantities.InternalChannelQoI(qoi)\n            ```\n\n            If a tuple or list of two integers is given, then the quantity \n            of interest is taken to be the comparative quantity for the \n            class given by the first integer against the class given by the \n            second integer, i.e., \n            ```python\n            quantities.ComparativeQoI(*qoi)\n            ```\n\n            If a callable is given, it is interpreted as a function\n            representing the QoI, i.e.,\n            ```python\n            quantities.LambdaQoI(qoi)\n            ```\n\n            If the string, `'max'`, is given, the quantity of interest is \n            taken to be the output for the class with the maximum score, \n            i.e., \n            ```python\n            quantities.MaxClassQoI()\n            ```\n\n        doi:\n            Distribution of interest over inputs. Expects a `DoI` object, or\n            a related type that can be interpreted as a `DoI`, as documented\n            below.\n\n            If the string, `'point'`, is given, the distribution is taken to\n            be the single point passed to `attributions`, i.e., \n            ```python\n            distributions.PointDoi()\n            ```\n\n            If the string, `'linear'`, is given, the distribution is taken \n            to be the linear interpolation from the zero input to the point \n            passed to `attributions`, i.e., \n            ```python\n            distributions.LinearDoi()\n            ```\n\n        multiply_activation:\n            Whether to multiply the gradient result by its corresponding\n            activation, thus converting from \"*influence space*\" to \n            \"*attribution space*.\"\n    \"\"\"\n    super().__init__(model, *args, **kwargs)\n\n    self.slice = InternalInfluence.__get_slice(cuts)\n    self.qoi = InternalInfluence.__get_qoi(qoi)\n    self.doi = InternalInfluence.__get_doi(doi, cut=self.slice.from_cut)\n    self._do_multiply = multiply_activation\n    self._return_grads = return_grads\n    self._return_doi = return_doi\n</code></pre>"},{"location":"api/distributions/","title":"Distributions of Interest","text":"<p>The distribution of interest lets us specify the set of samples over which we  want our explanations to be faithful. In some cases, we may want to explain the  model\u2019s behavior on a particular record, whereas other times we may be  interested in a more general behavior over a distribution of samples.</p>"},{"location":"api/distributions/#trulens.nn.distributions.DoI","title":"<code>DoI</code>","text":"<p>         Bases: <code>AbstractBaseClass</code></p> <p>Interface for distributions of interest. The Distribution of Interest  (DoI) specifies the samples over which an attribution method is  aggregated.</p> Source code in <code>trulens/nn/distributions.py</code> <pre><code>class DoI(AbstractBaseClass):\n\"\"\"\n    Interface for distributions of interest. The *Distribution of Interest* \n    (DoI) specifies the samples over which an attribution method is \n    aggregated.\n    \"\"\"\n\n    def __init__(self, cut: Cut = None):\n\"\"\"\"Initialize DoI\n\n        Parameters:\n            cut (Cut, optional): \n                The Cut in which the DoI will be applied. If `None`, the DoI will be\n                applied to the input. otherwise, the distribution should be applied\n                to the latent space defined by the cut. \n        \"\"\"\n        self._cut = cut\n\n    def __str__(self):\n        return render_object(self, ['_cut'])\n\n    def _wrap_public_call(\n        self, z: Inputs[TensorLike], *, model_inputs: ModelInputs\n    ) -&gt; Inputs[Uniform[TensorLike]]:\n\"\"\"Same as __call__ but input and output types are more specific and\n        less permissive. Formats the inputs for special cases that might be more\n        convenient for the user's __call__ implementation and formats its return\n        back to the consistent type.\"\"\"\n\n        z: Inputs[TensorLike] = om_of_many(z)\n\n        if accepts_model_inputs(self.__call__):\n            ret = self.__call__(z, model_inputs=model_inputs)\n        else:\n            ret = self.__call__(z)\n        # Wrap the public doi generator with appropriate type aliases.\n        if isinstance(ret, DATA_CONTAINER_TYPE):\n            if isinstance(ret[0], DATA_CONTAINER_TYPE):\n                ret = Inputs(Uniform(x) for x in ret)\n            else:\n                ret = Uniform(ret)\n\n            ret: Inputs[Uniform[TensorLike]] = many_of_om(\n                ret, innertype=Uniform\n            )\n        else:\n            ret: ArgsLike = [ret]\n        return ret\n\n    @abstractmethod\n    def __call__(\n        self,\n        z: OM[Inputs, TensorLike],\n        *,\n        model_inputs: Optional[ModelInputs] = None\n    ) -&gt; OM[Inputs, Uniform[TensorLike]]:\n\"\"\"\n        Computes the distribution of interest from an initial point. If z:\n        TensorLike is given, we assume there is only 1 input to the DoI layer. If\n        z: List[TensorLike] is given, it provides all of the inputs to the DoI\n        layer. \n\n        Either way, we always return List[List[TensorLike]] (alias\n        Inputs[Uniform[TensorLike]]) with outer list spanning layer inputs, and\n        inner list spanning a distribution's instance.\n\n        Parameters:\n            z:\n                Input point from which the distribution is derived. If\n                list/tuple, the point is defined by multiple tensors.\n            model_inputs:\n                Optional wrapped model input arguments that produce value z at\n                cut.\n\n        Returns:\n            List of points which are all assigned equal probability mass in the\n            distribution of interest, i.e., the distribution of interest is a\n            discrete, uniform distribution over the list of returned points. If\n            z is multi-input, returns a distribution for each input.\n        \"\"\"\n        raise NotImplementedError\n\n    # @property\n    def cut(self) -&gt; Cut:\n\"\"\"\n        Returns:\n            The Cut in which the DoI will be applied. If `None`, the DoI will be\n            applied to the input. otherwise, the distribution should be applied\n            to the latent space defined by the cut. \n        \"\"\"\n        return self._cut\n\n    def _wrap_public_get_activation_multiplier(\n        self, activation: Inputs[TensorLike], *, model_inputs: ModelInputs\n    ) -&gt; Inputs[TensorLike]:\n\"\"\"Same as get_activation_multiplier but without \"one-or-more\". \"\"\"\n\n        activations: OM[Inputs, TensorLike] = om_of_many(activation)\n\n        # get_activation_multiplier is public\n        if accepts_model_inputs(self.get_activation_multiplier):\n            ret: OM[Inputs, TensorLike] = self.get_activation_multiplier(\n                activations, model_inputs=model_inputs\n            )\n        else:\n            ret: OM[Inputs,\n                    TensorLike] = self.get_activation_multiplier(activations)\n\n        ret: Inputs[TensorLike] = many_of_om(ret)\n\n        return ret\n\n    def get_activation_multiplier(\n        self,\n        activation: OM[Inputs, TensorLike],\n        *,\n        model_inputs: Optional[ModelInputs] = None\n    ) -&gt; OM[Inputs, TensorLike]:\n\"\"\"\n        Returns a term to multiply the gradient by to convert from \"*influence\n        space*\" to \"*attribution space*\". Conceptually, \"influence space\"\n        corresponds to the potential effect of a slight increase in each\n        feature, while \"attribution space\" corresponds to an approximation of\n        the net marginal contribution to the quantity of interest of each\n        feature.\n\n        Parameters:\n            activation:\n                The activation of the layer the DoI is applied to. DoI may be\n                multi-input in which case activation will be a list.\n            model_inputs:\n                Optional wrapped model input arguments that produce activation\n                at cut.\n\n        Returns:\n            An array with the same shape as ``activation`` that will be\n            multiplied by the gradient to obtain the attribution. The default\n            implementation of this method simply returns ``activation``. If\n            activation is multi-input, returns one multiplier for each.\n        \"\"\"\n        return om_of_many(activation)\n\n    def _assert_cut_contains_only_one_tensor(self, x):\n        if isinstance(x, DATA_CONTAINER_TYPE) and len(x) == 1:\n            x = x[0]\n        if isinstance(x, MAP_CONTAINER_TYPE) and len(x) == 1:\n            x = list(x.values())[0]\n\n        if isinstance(x, list):\n            raise DoiCutSupportError(\n                '\\n\\n'\n                'Cut provided to distribution of interest was comprised of '\n                'multiple tensors, but `{}` is only defined for cuts comprised '\n                'of a single tensor (received a list of {} tensors).\\n'\n                '\\n'\n                'Either (1) select a slice where the `to_cut` corresponds to a '\n                'single tensor, or (2) implement/use a `DoI` object that '\n                'supports lists of tensors, i.e., where the parameter, `z`, to '\n                '`__call__` is expected/allowed to be a list of {} tensors.'.\n                format(self.__class__.__name__, len(x), len(x))\n            )\n\n        elif not (isinstance(x, np.ndarray) or get_backend().is_tensor(x)):\n            raise ValueError(\n                '`{}` expected to receive an instance of `Tensor` or '\n                '`np.ndarray`, but received an instance of {}'.format(\n                    self.__class__.__name__, type(x)\n                )\n            )\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.DoI.__call__","title":"<code>__call__(z, *, model_inputs=None)</code>  <code>abstractmethod</code>","text":"<p>Computes the distribution of interest from an initial point. If z: TensorLike is given, we assume there is only 1 input to the DoI layer. If z: List[TensorLike] is given, it provides all of the inputs to the DoI layer. </p> <p>Either way, we always return List[List[TensorLike]] (alias Inputs[Uniform[TensorLike]]) with outer list spanning layer inputs, and inner list spanning a distribution's instance.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>OM[Inputs, TensorLike]</code> <p>Input point from which the distribution is derived. If list/tuple, the point is defined by multiple tensors.</p> required <code>model_inputs</code> <code>Optional[ModelInputs]</code> <p>Optional wrapped model input arguments that produce value z at cut.</p> <code>None</code> <p>Returns:</p> Type Description <code>OM[Inputs, Uniform[TensorLike]]</code> <p>List of points which are all assigned equal probability mass in the</p> <code>OM[Inputs, Uniform[TensorLike]]</code> <p>distribution of interest, i.e., the distribution of interest is a</p> <code>OM[Inputs, Uniform[TensorLike]]</code> <p>discrete, uniform distribution over the list of returned points. If</p> <code>OM[Inputs, Uniform[TensorLike]]</code> <p>z is multi-input, returns a distribution for each input.</p> Source code in <code>trulens/nn/distributions.py</code> <pre><code>@abstractmethod\ndef __call__(\n    self,\n    z: OM[Inputs, TensorLike],\n    *,\n    model_inputs: Optional[ModelInputs] = None\n) -&gt; OM[Inputs, Uniform[TensorLike]]:\n\"\"\"\n    Computes the distribution of interest from an initial point. If z:\n    TensorLike is given, we assume there is only 1 input to the DoI layer. If\n    z: List[TensorLike] is given, it provides all of the inputs to the DoI\n    layer. \n\n    Either way, we always return List[List[TensorLike]] (alias\n    Inputs[Uniform[TensorLike]]) with outer list spanning layer inputs, and\n    inner list spanning a distribution's instance.\n\n    Parameters:\n        z:\n            Input point from which the distribution is derived. If\n            list/tuple, the point is defined by multiple tensors.\n        model_inputs:\n            Optional wrapped model input arguments that produce value z at\n            cut.\n\n    Returns:\n        List of points which are all assigned equal probability mass in the\n        distribution of interest, i.e., the distribution of interest is a\n        discrete, uniform distribution over the list of returned points. If\n        z is multi-input, returns a distribution for each input.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.DoI.__init__","title":"<code>__init__(cut=None)</code>","text":"<p>\"Initialize DoI</p> <p>Parameters:</p> Name Type Description Default <code>cut</code> <code>Cut</code> <p>The Cut in which the DoI will be applied. If <code>None</code>, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut.</p> <code>None</code> Source code in <code>trulens/nn/distributions.py</code> <pre><code>def __init__(self, cut: Cut = None):\n\"\"\"\"Initialize DoI\n\n    Parameters:\n        cut (Cut, optional): \n            The Cut in which the DoI will be applied. If `None`, the DoI will be\n            applied to the input. otherwise, the distribution should be applied\n            to the latent space defined by the cut. \n    \"\"\"\n    self._cut = cut\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.DoI.cut","title":"<code>cut()</code>","text":"<p>Returns:</p> Type Description <code>Cut</code> <p>The Cut in which the DoI will be applied. If <code>None</code>, the DoI will be</p> <code>Cut</code> <p>applied to the input. otherwise, the distribution should be applied</p> <code>Cut</code> <p>to the latent space defined by the cut.</p> Source code in <code>trulens/nn/distributions.py</code> <pre><code>def cut(self) -&gt; Cut:\n\"\"\"\n    Returns:\n        The Cut in which the DoI will be applied. If `None`, the DoI will be\n        applied to the input. otherwise, the distribution should be applied\n        to the latent space defined by the cut. \n    \"\"\"\n    return self._cut\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.DoI.get_activation_multiplier","title":"<code>get_activation_multiplier(activation, *, model_inputs=None)</code>","text":"<p>Returns a term to multiply the gradient by to convert from \"influence space\" to \"attribution space\". Conceptually, \"influence space\" corresponds to the potential effect of a slight increase in each feature, while \"attribution space\" corresponds to an approximation of the net marginal contribution to the quantity of interest of each feature.</p> <p>Parameters:</p> Name Type Description Default <code>activation</code> <code>OM[Inputs, TensorLike]</code> <p>The activation of the layer the DoI is applied to. DoI may be multi-input in which case activation will be a list.</p> required <code>model_inputs</code> <code>Optional[ModelInputs]</code> <p>Optional wrapped model input arguments that produce activation at cut.</p> <code>None</code> <p>Returns:</p> Type Description <code>OM[Inputs, TensorLike]</code> <p>An array with the same shape as <code>activation</code> that will be</p> <code>OM[Inputs, TensorLike]</code> <p>multiplied by the gradient to obtain the attribution. The default</p> <code>OM[Inputs, TensorLike]</code> <p>implementation of this method simply returns <code>activation</code>. If</p> <code>OM[Inputs, TensorLike]</code> <p>activation is multi-input, returns one multiplier for each.</p> Source code in <code>trulens/nn/distributions.py</code> <pre><code>def get_activation_multiplier(\n    self,\n    activation: OM[Inputs, TensorLike],\n    *,\n    model_inputs: Optional[ModelInputs] = None\n) -&gt; OM[Inputs, TensorLike]:\n\"\"\"\n    Returns a term to multiply the gradient by to convert from \"*influence\n    space*\" to \"*attribution space*\". Conceptually, \"influence space\"\n    corresponds to the potential effect of a slight increase in each\n    feature, while \"attribution space\" corresponds to an approximation of\n    the net marginal contribution to the quantity of interest of each\n    feature.\n\n    Parameters:\n        activation:\n            The activation of the layer the DoI is applied to. DoI may be\n            multi-input in which case activation will be a list.\n        model_inputs:\n            Optional wrapped model input arguments that produce activation\n            at cut.\n\n    Returns:\n        An array with the same shape as ``activation`` that will be\n        multiplied by the gradient to obtain the attribution. The default\n        implementation of this method simply returns ``activation``. If\n        activation is multi-input, returns one multiplier for each.\n    \"\"\"\n    return om_of_many(activation)\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.DoiCutSupportError","title":"<code>DoiCutSupportError</code>","text":"<p>         Bases: <code>ValueError</code></p> <p>Exception raised if the distribution of interest is called on a cut whose output is not supported by the distribution of interest.</p> Source code in <code>trulens/nn/distributions.py</code> <pre><code>class DoiCutSupportError(ValueError):\n\"\"\"\n    Exception raised if the distribution of interest is called on a cut whose\n    output is not supported by the distribution of interest.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.GaussianDoi","title":"<code>GaussianDoi</code>","text":"<p>         Bases: <code>DoI</code></p> <p>Distribution representing a Gaussian ball around the point. Used by Smooth Gradients.</p> Source code in <code>trulens/nn/distributions.py</code> <pre><code>class GaussianDoi(DoI):\n\"\"\"\n    Distribution representing a Gaussian ball around the point. Used by Smooth\n    Gradients.\n    \"\"\"\n\n    def __init__(self, var: float, resolution: int, cut: Cut = None):\n\"\"\"\n        Parameters:\n            var:\n                The variance of the Gaussian noise to be added around the point.\n\n            resolution:\n                Number of samples returned by each call to this DoI.\n            cut (Cut, optional): \n                The Cut in which the DoI will be applied. If `None`, the DoI will be\n                applied to the input. otherwise, the distribution should be applied\n                to the latent space defined by the cut. \n        \"\"\"\n        super(GaussianDoi, self).__init__(cut)\n        self._var = var\n        self._resolution = resolution\n\n    def __str__(self):\n        return render_object(self, ['_cut', '_var', '_resolution'])\n\n    def __call__(self, z: OM[Inputs,\n                             TensorLike]) -&gt; OM[Inputs, Uniform[TensorLike]]:\n        # Public interface.\n\n        B = get_backend()\n        self._assert_cut_contains_only_one_tensor(z)\n\n        def gauss_of_input(z: TensorLike) -&gt; Uniform[TensorLike]:\n            # TODO: make a pytorch backend with the same interface to use in places like these.\n\n            if B.is_tensor(z):\n                # Tensor implementation.\n                return [\n                    z + B.random_normal_like(z, var=self._var)\n                    for _ in range(self._resolution)\n                ]  # Uniform\n\n            else:\n                # Array implementation.\n                return [\n                    z + np.random.normal(0., np.sqrt(self._var), z.shape)\n                    for _ in range(self._resolution)\n                ]  # Uniform\n\n        z: Inputs[TensorLike] = many_of_om(z)\n\n        return om_of_many(nested_map(z, gauss_of_input))\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.GaussianDoi.__init__","title":"<code>__init__(var, resolution, cut=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>var</code> <code>float</code> <p>The variance of the Gaussian noise to be added around the point.</p> required <code>resolution</code> <code>int</code> <p>Number of samples returned by each call to this DoI.</p> required <code>cut</code> <code>Cut</code> <p>The Cut in which the DoI will be applied. If <code>None</code>, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut.</p> <code>None</code> Source code in <code>trulens/nn/distributions.py</code> <pre><code>def __init__(self, var: float, resolution: int, cut: Cut = None):\n\"\"\"\n    Parameters:\n        var:\n            The variance of the Gaussian noise to be added around the point.\n\n        resolution:\n            Number of samples returned by each call to this DoI.\n        cut (Cut, optional): \n            The Cut in which the DoI will be applied. If `None`, the DoI will be\n            applied to the input. otherwise, the distribution should be applied\n            to the latent space defined by the cut. \n    \"\"\"\n    super(GaussianDoi, self).__init__(cut)\n    self._var = var\n    self._resolution = resolution\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.LinearDoi","title":"<code>LinearDoi</code>","text":"<p>         Bases: <code>DoI</code></p> <p>Distribution representing the linear interpolation between a baseline and  the given point. Used by Integrated Gradients.</p> Source code in <code>trulens/nn/distributions.py</code> <pre><code>class LinearDoi(DoI):\n\"\"\"\n    Distribution representing the linear interpolation between a baseline and \n    the given point. Used by Integrated Gradients.\n    \"\"\"\n\n    def __init__(\n        self,\n        baseline: BaselineLike = None,\n        resolution: int = 10,\n        *,\n        cut: Cut = None,\n    ):\n\"\"\"\n        The DoI for point, `z`, will be a uniform distribution over the points\n        on the line segment connecting `z` to `baseline`, approximated by a\n        sample of `resolution` points equally spaced along this segment.\n\n        Parameters:\n            cut (Cut, optional, from DoI): \n                The Cut in which the DoI will be applied. If `None`, the DoI\n                will be applied to the input. otherwise, the distribution should\n                be applied to the latent space defined by the cut. \n            baseline (BaselineLike, optional):\n                The baseline to interpolate from. Must be same shape as the\n                space the distribution acts over, i.e., the shape of the points,\n                `z`, eventually passed to `__call__`. If `cut` is `None`, this\n                must be the same shape as the input, otherwise this must be the\n                same shape as the latent space defined by the cut. If `None` is\n                given, `baseline` will be the zero vector in the appropriate\n                shape. If the baseline is callable, it is expected to return the\n                `baseline`, given `z` and optional model arguments.\n            resolution (int):\n                Number of points returned by each call to this DoI. A higher\n                resolution is more computationally expensive, but gives a better\n                approximation of the DoI this object mathematically represents.\n        \"\"\"\n        super(LinearDoi, self).__init__(cut)\n        self._baseline = baseline\n        self._resolution = resolution\n\n    @property\n    def baseline(self) -&gt; BaselineLike:\n        return self._baseline\n\n    @property\n    def resolution(self) -&gt; int:\n        return self._resolution\n\n    def __str__(self):\n        return render_object(self, ['_cut', '_baseline', '_resolution'])\n\n    def __call__(\n        self,\n        z: OM[Inputs, TensorLike],\n        *,\n        model_inputs: Optional[ModelInputs] = None\n    ) -&gt; OM[Inputs, Uniform[TensorLike]]:\n\n        self._assert_cut_contains_only_one_tensor(z)\n\n        z: Inputs[TensorLike] = many_of_om(z)\n\n        baseline = self._compute_baseline(z, model_inputs=model_inputs)\n\n        r = 1. if self._resolution == 1 else self._resolution - 1.\n        zipped = nested_zip(z, baseline)\n\n        def zipped_interpolate(zipped_z_baseline):\n\"\"\"interpolates zipped elements\n\n            Args:\n                zipped_z_baseline: A tuple expecting the first element to be the z_val, and second to be the baseline.\n\n            Returns:\n                a list of interpolations from z to baseline\n            \"\"\"\n            z_ = zipped_z_baseline[0]\n            b_ = zipped_z_baseline[1]\n            return [ # Uniform\n                (1. - i / r) * z_ + i / r * b_\n                for i in range(self._resolution)\n            ]\n\n        ret = om_of_many(\n            nested_map(\n                zipped, zipped_interpolate, check_accessor=lambda x: x[0]\n            )\n        )\n\n        return ret\n\n    def get_activation_multiplier(\n        self,\n        activation: OM[Inputs, TensorLike],\n        *,\n        model_inputs: Optional[ModelInputs] = None\n    ) -&gt; Inputs[TensorLike]:\n\"\"\"\n        Returns a term to multiply the gradient by to convert from \"*influence \n        space*\" to \"*attribution space*\". Conceptually, \"influence space\"\n        corresponds to the potential effect of a slight increase in each \n        feature, while \"attribution space\" corresponds to an approximation of\n        the net marginal contribution to the quantity of interest of each \n        feature.\n\n        Parameters:\n            activation:\n                The activation of the layer the DoI is applied to.\n\n        Returns:\n            The activation adjusted by the baseline passed to the constructor.\n        \"\"\"\n\n        activation: Inputs[TensorLike] = many_of_om(activation)\n\n        baseline: Inputs[TensorLike] = self._compute_baseline(\n            activation, model_inputs=model_inputs\n        )\n\n        if baseline is None:\n            return activation\n\n        zipped = nested_zip(activation, baseline)\n\n        def zipped_subtract(zipped_activation_baseline):\n\"\"\"subtracts zipped elements\n\n            Args:\n                zipped_activation_baseline: A tuple expecting the first element to be the activation, and second to be the baseline.\n\n            Returns:\n                a subtraction of activation and baseline\n            \"\"\"\n            activation = zipped_activation_baseline[0]\n            baseline = zipped_activation_baseline[1]\n            return activation - baseline\n\n        ret = nested_map(zipped, zipped_subtract, check_accessor=lambda x: x[0])\n        return ret\n\n    def _compute_baseline(\n        self,\n        z: Inputs[TensorLike],\n        *,\n        model_inputs: Optional[ModelInputs] = None\n    ) -&gt; Inputs[TensorLike]:\n\n        B = get_backend()\n\n        _baseline: BaselineLike = self.baseline  # user-provided\n\n        if isinstance(_baseline, Callable):\n            if accepts_model_inputs(_baseline):\n                _baseline: OM[Inputs, TensorLike] = many_of_om(\n                    _baseline(om_of_many(z), model_inputs=model_inputs)\n                )\n            else:\n                _baseline: OM[Inputs, TensorLike] = many_of_om(\n                    _baseline(om_of_many(z))\n                )\n\n        else:\n            _baseline: OM[Inputs, TensorLike]\n\n        if _baseline is None:\n            _baseline: Inputs[TensorLike] = nested_map(z, B.zeros_like)\n        else:\n            _baseline: Inputs[TensorLike] = many_of_om(_baseline)\n            # Came from user; could have been single or multiple inputs.\n        tensor_wrapper = TensorAKs(args=z)\n        # Cast to either Tensor or numpy.ndarray to match what was given in z.\n        return nested_cast(\n            backend=B,\n            args=_baseline,\n            astype=type(tensor_wrapper.first_batchable(B))\n        )\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.LinearDoi.__init__","title":"<code>__init__(baseline=None, resolution=10, *, cut=None)</code>","text":"<p>The DoI for point, <code>z</code>, will be a uniform distribution over the points on the line segment connecting <code>z</code> to <code>baseline</code>, approximated by a sample of <code>resolution</code> points equally spaced along this segment.</p> <p>Parameters:</p> Name Type Description Default <code>cut</code> <code>Cut, optional, from DoI</code> <p>The Cut in which the DoI will be applied. If <code>None</code>, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. </p> <code>None</code> <code>baseline</code> <code>BaselineLike</code> <p>The baseline to interpolate from. Must be same shape as the space the distribution acts over, i.e., the shape of the points, <code>z</code>, eventually passed to <code>__call__</code>. If <code>cut</code> is <code>None</code>, this must be the same shape as the input, otherwise this must be the same shape as the latent space defined by the cut. If <code>None</code> is given, <code>baseline</code> will be the zero vector in the appropriate shape. If the baseline is callable, it is expected to return the <code>baseline</code>, given <code>z</code> and optional model arguments.</p> <code>None</code> <code>resolution</code> <code>int</code> <p>Number of points returned by each call to this DoI. A higher resolution is more computationally expensive, but gives a better approximation of the DoI this object mathematically represents.</p> <code>10</code> Source code in <code>trulens/nn/distributions.py</code> <pre><code>def __init__(\n    self,\n    baseline: BaselineLike = None,\n    resolution: int = 10,\n    *,\n    cut: Cut = None,\n):\n\"\"\"\n    The DoI for point, `z`, will be a uniform distribution over the points\n    on the line segment connecting `z` to `baseline`, approximated by a\n    sample of `resolution` points equally spaced along this segment.\n\n    Parameters:\n        cut (Cut, optional, from DoI): \n            The Cut in which the DoI will be applied. If `None`, the DoI\n            will be applied to the input. otherwise, the distribution should\n            be applied to the latent space defined by the cut. \n        baseline (BaselineLike, optional):\n            The baseline to interpolate from. Must be same shape as the\n            space the distribution acts over, i.e., the shape of the points,\n            `z`, eventually passed to `__call__`. If `cut` is `None`, this\n            must be the same shape as the input, otherwise this must be the\n            same shape as the latent space defined by the cut. If `None` is\n            given, `baseline` will be the zero vector in the appropriate\n            shape. If the baseline is callable, it is expected to return the\n            `baseline`, given `z` and optional model arguments.\n        resolution (int):\n            Number of points returned by each call to this DoI. A higher\n            resolution is more computationally expensive, but gives a better\n            approximation of the DoI this object mathematically represents.\n    \"\"\"\n    super(LinearDoi, self).__init__(cut)\n    self._baseline = baseline\n    self._resolution = resolution\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.LinearDoi.get_activation_multiplier","title":"<code>get_activation_multiplier(activation, *, model_inputs=None)</code>","text":"<p>Returns a term to multiply the gradient by to convert from \"influence  space\" to \"attribution space\". Conceptually, \"influence space\" corresponds to the potential effect of a slight increase in each  feature, while \"attribution space\" corresponds to an approximation of the net marginal contribution to the quantity of interest of each  feature.</p> <p>Parameters:</p> Name Type Description Default <code>activation</code> <code>OM[Inputs, TensorLike]</code> <p>The activation of the layer the DoI is applied to.</p> required <p>Returns:</p> Type Description <code>Inputs[TensorLike]</code> <p>The activation adjusted by the baseline passed to the constructor.</p> Source code in <code>trulens/nn/distributions.py</code> <pre><code>def get_activation_multiplier(\n    self,\n    activation: OM[Inputs, TensorLike],\n    *,\n    model_inputs: Optional[ModelInputs] = None\n) -&gt; Inputs[TensorLike]:\n\"\"\"\n    Returns a term to multiply the gradient by to convert from \"*influence \n    space*\" to \"*attribution space*\". Conceptually, \"influence space\"\n    corresponds to the potential effect of a slight increase in each \n    feature, while \"attribution space\" corresponds to an approximation of\n    the net marginal contribution to the quantity of interest of each \n    feature.\n\n    Parameters:\n        activation:\n            The activation of the layer the DoI is applied to.\n\n    Returns:\n        The activation adjusted by the baseline passed to the constructor.\n    \"\"\"\n\n    activation: Inputs[TensorLike] = many_of_om(activation)\n\n    baseline: Inputs[TensorLike] = self._compute_baseline(\n        activation, model_inputs=model_inputs\n    )\n\n    if baseline is None:\n        return activation\n\n    zipped = nested_zip(activation, baseline)\n\n    def zipped_subtract(zipped_activation_baseline):\n\"\"\"subtracts zipped elements\n\n        Args:\n            zipped_activation_baseline: A tuple expecting the first element to be the activation, and second to be the baseline.\n\n        Returns:\n            a subtraction of activation and baseline\n        \"\"\"\n        activation = zipped_activation_baseline[0]\n        baseline = zipped_activation_baseline[1]\n        return activation - baseline\n\n    ret = nested_map(zipped, zipped_subtract, check_accessor=lambda x: x[0])\n    return ret\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.PointDoi","title":"<code>PointDoi</code>","text":"<p>         Bases: <code>DoI</code></p> <p>Distribution that puts all probability mass on a single point.</p> Source code in <code>trulens/nn/distributions.py</code> <pre><code>class PointDoi(DoI):\n\"\"\"\n    Distribution that puts all probability mass on a single point.\n    \"\"\"\n\n    def __init__(self, cut: Cut = None):\n\"\"\"\"Initialize PointDoI\n\n        Parameters:\n            cut (Cut, optional): \n                The Cut in which the DoI will be applied. If `None`, the DoI will be\n                applied to the input. otherwise, the distribution should be applied\n                to the latent space defined by the cut. \n        \"\"\"\n        super(PointDoi, self).__init__(cut)\n\n    def __call__(\n        self,\n        z: OM[Inputs, TensorLike],\n        *,\n        model_inputs: Optional[ModelInputs] = None\n    ) -&gt; OM[Inputs, Uniform[TensorLike]]:\n\n        z: Inputs[TensorLike] = many_of_om(z)\n\n        return om_of_many(nested_map(z, lambda x: [x]))\n</code></pre>"},{"location":"api/distributions/#trulens.nn.distributions.PointDoi.__init__","title":"<code>__init__(cut=None)</code>","text":"<p>\"Initialize PointDoI</p> <p>Parameters:</p> Name Type Description Default <code>cut</code> <code>Cut</code> <p>The Cut in which the DoI will be applied. If <code>None</code>, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut.</p> <code>None</code> Source code in <code>trulens/nn/distributions.py</code> <pre><code>def __init__(self, cut: Cut = None):\n\"\"\"\"Initialize PointDoI\n\n    Parameters:\n        cut (Cut, optional): \n            The Cut in which the DoI will be applied. If `None`, the DoI will be\n            applied to the input. otherwise, the distribution should be applied\n            to the latent space defined by the cut. \n    \"\"\"\n    super(PointDoi, self).__init__(cut)\n</code></pre>"},{"location":"api/model_wrappers/","title":"Model Wrappers","text":"<p>The TruLens library is designed to support models implemented via a variety of different popular python neural network frameworks: Keras (with TensorFlow or  Theano backend), TensorFlow, and Pytorch. Models developed with different frameworks  implement things (e.g., gradient computations) a number of different ways. We define  framework specific <code>ModelWrapper</code> instances to create a unified model API, providing the same  functionality to models that are implemented in disparate frameworks. In order to compute  attributions for a model, we provide a <code>trulens.nn.models.get_model_wrapper</code> function that will return an appropriate <code>ModelWrapper</code> instance.</p> <p>Some parameters are exclusively utilized for specific frameworks and are outlined  in the parameter descriptions.</p>"},{"location":"api/model_wrappers/#trulens.nn.models.get_model_wrapper","title":"<code>get_model_wrapper(model, *, logit_layer=None, replace_softmax=False, softmax_layer=-1, custom_objects=None, device=None, input_tensors=None, output_tensors=None, internal_tensor_dict=None, default_feed_dict=None, session=None, backend=None, force_eval=True, **kwargs)</code>","text":"<p>Returns a ModelWrapper implementation that exposes the components needed for computing attributions.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ModelLike</code> <p>The model to wrap. If using the TensorFlow 1 backend, this is  expected to be a graph object.</p> required <code>logit_layer</code> <p>Supported for Keras and Pytorch models.  Specifies the name or index of the layer that produces the logit predictions. </p> <code>None</code> <code>replace_softmax</code> <code>bool</code> <p>Supported for Keras models only. If true, the activation function in the softmax layer (specified by <code>softmax_layer</code>)  will be changed to a <code>'linear'</code> activation. </p> <code>False</code> <code>softmax_layer</code> <p>Supported for Keras models only. Specifies the layer that performs the softmax. This layer should have an <code>activation</code> attribute. Only used when <code>replace_softmax</code> is true.</p> <code>-1</code> <code>custom_objects</code> <p>Optional, for use with Keras models only. A dictionary of custom objects used by the Keras model.</p> <code>None</code> <code>device</code> <code>str</code> <p>Optional, for use with Pytorch models only. A string specifying the device to run the model on.</p> <code>None</code> <code>input_tensors</code> <p>Required for use with TensorFlow 1 graph models only. A list of tensors representing the input to the model graph.</p> <code>None</code> <code>output_tensors</code> <p>Required for use with TensorFlow 1 graph models only. A list of tensors representing the output to the model graph.</p> <code>None</code> <code>internal_tensor_dict</code> <p>Optional, for use with TensorFlow 1 graph models only. A dictionary mapping user-selected layer names to the internal tensors in the model graph that the user would like to expose. This is provided to give more human-readable names to the layers if desired. Internal tensors can also be accessed via the name given to them by tensorflow.</p> <code>None</code> <code>default_feed_dict</code> <p>Optional, for use with TensorFlow 1 graph models only. A dictionary of default values to give to tensors in the model graph.</p> <code>None</code> <code>session</code> <p>Optional, for use with TensorFlow 1 graph models only. A  <code>tf.Session</code> object to run the model graph in. If <code>None</code>, a new temporary session will be generated every time the model is run.</p> <code>None</code> <code>backend</code> <p>Optional, for forcing a specific backend. String values recognized are pytorch, tensorflow, keras, or tf.keras.</p> <code>None</code> <code>force_eval</code> <p>_Optional, True will force a model.eval() call for PyTorch models. False will retain current model state</p> <code>True</code> Source code in <code>trulens/nn/models/__init__.py</code> <pre><code>def get_model_wrapper(\n    model: ModelLike,\n    *,\n    logit_layer=None,\n    replace_softmax: bool = False,\n    softmax_layer=-1,\n    custom_objects=None,\n    device: str = None,\n    input_tensors=None,\n    output_tensors=None,\n    internal_tensor_dict=None,\n    default_feed_dict=None,\n    session=None,\n    backend=None,\n    force_eval=True,\n    **kwargs\n):\n\"\"\"\n    Returns a ModelWrapper implementation that exposes the components needed for computing attributions.\n\n    Parameters:\n        model:\n            The model to wrap. If using the TensorFlow 1 backend, this is \n            expected to be a graph object.\n\n        logit_layer:\n            _Supported for Keras and Pytorch models._ \n            Specifies the name or index of the layer that produces the\n            logit predictions. \n\n        replace_softmax:\n            _Supported for Keras models only._ If true, the activation\n            function in the softmax layer (specified by `softmax_layer`) \n            will be changed to a `'linear'` activation. \n\n        softmax_layer:\n            _Supported for Keras models only._ Specifies the layer that\n            performs the softmax. This layer should have an `activation`\n            attribute. Only used when `replace_softmax` is true.\n\n        custom_objects:\n            _Optional, for use with Keras models only._ A dictionary of\n            custom objects used by the Keras model.\n\n        device:\n            _Optional, for use with Pytorch models only._ A string\n            specifying the device to run the model on.\n\n        input_tensors:\n            _Required for use with TensorFlow 1 graph models only._ A list\n            of tensors representing the input to the model graph.\n\n        output_tensors:\n            _Required for use with TensorFlow 1 graph models only._ A list\n            of tensors representing the output to the model graph.\n\n        internal_tensor_dict:\n            _Optional, for use with TensorFlow 1 graph models only._ A\n            dictionary mapping user-selected layer names to the internal\n            tensors in the model graph that the user would like to expose.\n            This is provided to give more human-readable names to the layers\n            if desired. Internal tensors can also be accessed via the name\n            given to them by tensorflow.\n\n        default_feed_dict:\n            _Optional, for use with TensorFlow 1 graph models only._ A\n            dictionary of default values to give to tensors in the model\n            graph.\n\n        session:\n            _Optional, for use with TensorFlow 1 graph models only._ A \n            `tf.Session` object to run the model graph in. If `None`, a new\n            temporary session will be generated every time the model is run.\n\n        backend:\n            _Optional, for forcing a specific backend._ String values recognized\n            are pytorch, tensorflow, keras, or tf.keras.\n\n        force_eval:\n            _Optional, True will force a model.eval() call for PyTorch models. False\n            will retain current model state\n\n    Returns: ModelWrapper\n    \"\"\"\n\n    if 'input_shape' in kwargs:\n        tru_logger.deprecate(\n            f\"get_model_wrapper: input_shape parameter is no longer used and will be removed in the future\"\n        )\n        del kwargs['input_shape']\n    if 'input_dtype' in kwargs:\n        tru_logger.deprecate(\n            f\"get_model_wrapper: input_dtype parameter is no longer used and will be removed in the future\"\n        )\n        del kwargs['input_dtype']\n\n    # get existing backend\n    B = get_backend(suppress_warnings=True)\n\n    if backend is None:\n        backend = discern_backend(model)\n        tru_logger.info(\n            \"Detected {} backend for {}.\".format(\n                backend.name.lower(), type(model)\n            )\n        )\n    else:\n        backend = Backend.from_name(backend)\n    if B is None or (backend is not Backend.UNKNOWN and B.backend != backend):\n        tru_logger.info(\n            \"Changing backend from {} to {}.\".format(\n                None if B is None else B.backend, backend\n            )\n        )\n        os.environ['TRULENS_BACKEND'] = backend.name.lower()\n        B = get_backend()\n    else:\n        tru_logger.info(\"Using backend {}.\".format(B.backend))\n    tru_logger.info(\n        \"If this seems incorrect, you can force the correct backend by passing the `backend` parameter directly into your get_model_wrapper call.\"\n    )\n    if B.backend.is_keras_derivative():\n        from trulens.nn.models.keras import KerasModelWrapper\n        return KerasModelWrapper(\n            model,\n            logit_layer=logit_layer,\n            replace_softmax=replace_softmax,\n            softmax_layer=softmax_layer,\n            custom_objects=custom_objects\n        )\n\n    elif B.backend == Backend.PYTORCH:\n        from trulens.nn.models.pytorch import PytorchModelWrapper\n        return PytorchModelWrapper(\n            model,\n            logit_layer=logit_layer,\n            device=device,\n            force_eval=force_eval\n        )\n    elif B.backend == Backend.TENSORFLOW:\n        import tensorflow as tf\n        if tf.__version__.startswith('2'):\n            from trulens.nn.models.tensorflow_v2 import Tensorflow2ModelWrapper\n            return Tensorflow2ModelWrapper(\n                model,\n                logit_layer=logit_layer,\n                replace_softmax=replace_softmax,\n                softmax_layer=softmax_layer,\n                custom_objects=custom_objects\n            )\n        else:\n            from trulens.nn.models.tensorflow_v1 import TensorflowModelWrapper\n            if input_tensors is None:\n                tru_logger.error(\n                    'tensorflow1 model must pass parameter: input_tensors'\n                )\n            if output_tensors is None:\n                tru_logger.error(\n                    'tensorflow1 model must pass parameter: output_tensors'\n                )\n            return TensorflowModelWrapper(\n                model,\n                input_tensors=input_tensors,\n                output_tensors=output_tensors,\n                internal_tensor_dict=internal_tensor_dict,\n                session=session\n            )\n</code></pre>"},{"location":"api/quantities/","title":"Quantities of Interest","text":"<p>A Quantity of Interest (QoI) is a function of the output that determines the  network output behavior that the attributions describe.</p> <p>The quantity of interest lets us specify what we want to explain. Often, this is the output of the network corresponding to a particular class, addressing, e.g., \"Why did the model classify a given image as a car?\" However, we could also  consider various combinations of outputs, allowing us to ask more specific  questions, such as, \"Why did the model classify a given image as a sedan and  not a convertible?\" The former may highlight general \u201ccar features,\u201d such as  tires, while the latter (called a comparative explanation) might focus on the  roof of the car, a \u201ccar feature\u201d not shared by convertibles.</p>"},{"location":"api/quantities/#trulens.nn.quantities.ClassQoI","title":"<code>ClassQoI</code>","text":"<p>         Bases: <code>QoI</code></p> <p>Quantity of interest for attributing output towards a specified class.</p> Source code in <code>trulens/nn/quantities.py</code> <pre><code>class ClassQoI(QoI):\n\"\"\"\n    Quantity of interest for attributing output towards a specified class.\n    \"\"\"\n\n    def __init__(self, cl: int):\n\"\"\"\n        Parameters:\n            cl:\n                The index of the class the QoI is for.\n        \"\"\"\n        self.cl = cl\n\n    def __str__(self):\n        return render_object(self, [\"cl\"])\n\n    def __call__(self, y: TensorLike) -&gt; TensorLike:\n        self._assert_cut_contains_only_one_tensor(y)\n\n        return y[:, self.cl]\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.ClassQoI.__init__","title":"<code>__init__(cl)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>cl</code> <code>int</code> <p>The index of the class the QoI is for.</p> required Source code in <code>trulens/nn/quantities.py</code> <pre><code>def __init__(self, cl: int):\n\"\"\"\n    Parameters:\n        cl:\n            The index of the class the QoI is for.\n    \"\"\"\n    self.cl = cl\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.ClassSeqQoI","title":"<code>ClassSeqQoI</code>","text":"<p>         Bases: <code>QoI</code></p> <p>Quantity of interest for attributing output towards a sequence of classes  for each input.</p> Source code in <code>trulens/nn/quantities.py</code> <pre><code>class ClassSeqQoI(QoI):\n\"\"\"\n    Quantity of interest for attributing output towards a sequence of classes \n    for each input.\n    \"\"\"\n\n    def __init__(self, seq_labels: List[int]):\n\"\"\"\n        Parameters:\n            seq_labels:\n                A sequence of classes corresponding to each input.\n        \"\"\"\n        self.seq_labels = seq_labels\n\n    def __call__(self, y):\n\n        self._assert_cut_contains_only_one_tensor(y)\n        assert get_backend().shape(y)[0] == len(self.seq_labels)\n\n        return y[:, self.seq_labels]\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.ClassSeqQoI.__init__","title":"<code>__init__(seq_labels)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>seq_labels</code> <code>List[int]</code> <p>A sequence of classes corresponding to each input.</p> required Source code in <code>trulens/nn/quantities.py</code> <pre><code>def __init__(self, seq_labels: List[int]):\n\"\"\"\n    Parameters:\n        seq_labels:\n            A sequence of classes corresponding to each input.\n    \"\"\"\n    self.seq_labels = seq_labels\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.ComparativeQoI","title":"<code>ComparativeQoI</code>","text":"<p>         Bases: <code>QoI</code></p> <p>Quantity of interest for attributing network output towards a given class,  relative to another.</p> Source code in <code>trulens/nn/quantities.py</code> <pre><code>class ComparativeQoI(QoI):\n\"\"\"\n    Quantity of interest for attributing network output towards a given class, \n    relative to another.\n    \"\"\"\n\n    def __init__(self, cl1: int, cl2: int):\n\"\"\"\n        Parameters:\n            cl1:\n                The index of the class the QoI is for.\n            cl2:\n                The index of the class to compare against.\n        \"\"\"\n        self.cl1 = cl1\n        self.cl2 = cl2\n\n    def __str__(self):\n        return render_object(self, [\"cl1\", \"cl2\"])\n\n    def __call__(self, y: TensorLike) -&gt; TensorLike:\n\n        self._assert_cut_contains_only_one_tensor(y)\n\n        return y[:, self.cl1] - y[:, self.cl2]\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.ComparativeQoI.__init__","title":"<code>__init__(cl1, cl2)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>cl1</code> <code>int</code> <p>The index of the class the QoI is for.</p> required <code>cl2</code> <code>int</code> <p>The index of the class to compare against.</p> required Source code in <code>trulens/nn/quantities.py</code> <pre><code>def __init__(self, cl1: int, cl2: int):\n\"\"\"\n    Parameters:\n        cl1:\n            The index of the class the QoI is for.\n        cl2:\n            The index of the class to compare against.\n    \"\"\"\n    self.cl1 = cl1\n    self.cl2 = cl2\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.InternalChannelQoI","title":"<code>InternalChannelQoI</code>","text":"<p>         Bases: <code>QoI</code></p> <p>Quantity of interest for attributing output towards the output of an  internal convolutional layer channel, aggregating using a specified  operation.</p> <p>Also works for non-convolutional dense layers, where the given neuron's activation is returned.</p> Source code in <code>trulens/nn/quantities.py</code> <pre><code>class InternalChannelQoI(QoI):\n\"\"\"\n    Quantity of interest for attributing output towards the output of an \n    internal convolutional layer channel, aggregating using a specified \n    operation.\n\n    Also works for non-convolutional dense layers, where the given neuron's\n    activation is returned.\n    \"\"\"\n\n    @staticmethod\n    def _batch_sum(x):\n\"\"\"\n        Sums batched 2D channels, leaving the batch dimension unchanged.\n        \"\"\"\n        return get_backend().sum(x, axis=(1, 2))\n\n    def __init__(\n        self,\n        channel: Union[int, List[int]],\n        channel_axis: Optional[int] = None,\n        agg_fn: Optional[Callable] = None\n    ):\n\"\"\"\n        Parameters:\n            channel:\n                Channel to return. If a list is provided, then the quantity sums \n                over each of the channels in the list.\n\n            channel_axis:\n                Channel dimension index, if relevant, e.g., for 2D convolutional\n                layers. If `channel_axis` is `None`, then the channel axis of \n                the relevant backend will be used. This argument is not used \n                when the channels are scalars, e.g., for dense layers.\n\n            agg_fn:\n                Function with which to aggregate the remaining dimensions \n                (except the batch dimension) in order to get a single scalar \n                value for each channel. If `agg_fn` is `None` then a sum over \n                each neuron in the channel will be taken. This argument is not \n                used when the channels are scalars, e.g., for dense layers.\n        \"\"\"\n        if channel_axis is None:\n            channel_axis = get_backend().channel_axis\n        if agg_fn is None:\n            agg_fn = InternalChannelQoI._batch_sum\n\n        self._channel_ax = channel_axis\n        self._agg_fn = agg_fn\n        self._channels = channel if isinstance(channel, list) else [channel]\n\n    def __call__(self, y: TensorLike) -&gt; TensorLike:\n        B = get_backend()\n        self._assert_cut_contains_only_one_tensor(y)\n\n        if len(B.int_shape(y)) == 2:\n            return sum([y[:, ch] for ch in self._channels])\n\n        elif len(B.int_shape(y)) == 3:\n            return sum([self._agg_fn(y[:, :, ch]) for ch in self._channel])\n\n        elif len(B.int_shape(y)) == 4:\n            if self._channel_ax == 1:\n                return sum([self._agg_fn(y[:, ch]) for ch in self._channels])\n\n            elif self._channel_ax == 3:\n                return sum(\n                    [self._agg_fn(y[:, :, :, ch]) for ch in self._channels]\n                )\n\n            else:\n                raise ValueError(\n                    'Unsupported channel axis for convolutional layer: {}'.\n                    format(self._channel_ax)\n                )\n\n        else:\n            raise QoiCutSupportError(\n                'Unsupported tensor rank for `InternalChannelQoI`: {}'.format(\n                    len(B.int_shape(y))\n                )\n            )\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.InternalChannelQoI.__init__","title":"<code>__init__(channel, channel_axis=None, agg_fn=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Union[int, List[int]]</code> <p>Channel to return. If a list is provided, then the quantity sums  over each of the channels in the list.</p> required <code>channel_axis</code> <code>Optional[int]</code> <p>Channel dimension index, if relevant, e.g., for 2D convolutional layers. If <code>channel_axis</code> is <code>None</code>, then the channel axis of  the relevant backend will be used. This argument is not used  when the channels are scalars, e.g., for dense layers.</p> <code>None</code> <code>agg_fn</code> <code>Optional[Callable]</code> <p>Function with which to aggregate the remaining dimensions  (except the batch dimension) in order to get a single scalar  value for each channel. If <code>agg_fn</code> is <code>None</code> then a sum over  each neuron in the channel will be taken. This argument is not  used when the channels are scalars, e.g., for dense layers.</p> <code>None</code> Source code in <code>trulens/nn/quantities.py</code> <pre><code>def __init__(\n    self,\n    channel: Union[int, List[int]],\n    channel_axis: Optional[int] = None,\n    agg_fn: Optional[Callable] = None\n):\n\"\"\"\n    Parameters:\n        channel:\n            Channel to return. If a list is provided, then the quantity sums \n            over each of the channels in the list.\n\n        channel_axis:\n            Channel dimension index, if relevant, e.g., for 2D convolutional\n            layers. If `channel_axis` is `None`, then the channel axis of \n            the relevant backend will be used. This argument is not used \n            when the channels are scalars, e.g., for dense layers.\n\n        agg_fn:\n            Function with which to aggregate the remaining dimensions \n            (except the batch dimension) in order to get a single scalar \n            value for each channel. If `agg_fn` is `None` then a sum over \n            each neuron in the channel will be taken. This argument is not \n            used when the channels are scalars, e.g., for dense layers.\n    \"\"\"\n    if channel_axis is None:\n        channel_axis = get_backend().channel_axis\n    if agg_fn is None:\n        agg_fn = InternalChannelQoI._batch_sum\n\n    self._channel_ax = channel_axis\n    self._agg_fn = agg_fn\n    self._channels = channel if isinstance(channel, list) else [channel]\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.LambdaQoI","title":"<code>LambdaQoI</code>","text":"<p>         Bases: <code>QoI</code></p> <p>Generic quantity of interest allowing the user to specify a function of the model's output as the QoI.</p> Source code in <code>trulens/nn/quantities.py</code> <pre><code>class LambdaQoI(QoI):\n\"\"\"\n    Generic quantity of interest allowing the user to specify a function of the\n    model's output as the QoI.\n    \"\"\"\n\n    def __init__(self, function: Callable):\n\"\"\"\n        Parameters:\n            function:\n                A callable that takes a single argument representing the model's \n                tensor output and returns a differentiable batched scalar tensor \n                representing the QoI.\n        \"\"\"\n        if len(signature(function).parameters) != 1:\n            raise ValueError(\n                'QoI function must take exactly 1 argument, but provided '\n                'function takes {} arguments'.format(\n                    len(signature(function).parameters)\n                )\n            )\n\n        self.function = function\n\n    def __call__(self, y: TensorLike) -&gt; TensorLike:\n        return self.function(y)\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.LambdaQoI.__init__","title":"<code>__init__(function)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable</code> <p>A callable that takes a single argument representing the model's  tensor output and returns a differentiable batched scalar tensor  representing the QoI.</p> required Source code in <code>trulens/nn/quantities.py</code> <pre><code>def __init__(self, function: Callable):\n\"\"\"\n    Parameters:\n        function:\n            A callable that takes a single argument representing the model's \n            tensor output and returns a differentiable batched scalar tensor \n            representing the QoI.\n    \"\"\"\n    if len(signature(function).parameters) != 1:\n        raise ValueError(\n            'QoI function must take exactly 1 argument, but provided '\n            'function takes {} arguments'.format(\n                len(signature(function).parameters)\n            )\n        )\n\n    self.function = function\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.MaxClassQoI","title":"<code>MaxClassQoI</code>","text":"<p>         Bases: <code>QoI</code></p> <p>Quantity of interest for attributing output towards the maximum-predicted  class.</p> Source code in <code>trulens/nn/quantities.py</code> <pre><code>class MaxClassQoI(QoI):\n\"\"\"\n    Quantity of interest for attributing output towards the maximum-predicted \n    class.\n    \"\"\"\n\n    def __init__(\n        self, axis: int = 1, activation: Union[Callable, str, None] = None\n    ):\n\"\"\"\n        Parameters:\n            axis:\n                Output dimension over which max operation is taken.\n\n            activation:\n                Activation function to be applied to the output before taking \n                the max. If `activation` is a string, use the corresponding \n                named activation function implemented by the backend. The \n                following strings are currently supported as shorthands for the\n                respective standard activation functions:\n\n                - `'sigmoid'` \n                - `'softmax'` \n\n                If `activation` is `None`, no activation function is applied to\n                the input.\n        \"\"\"\n        self._axis = axis\n        self.activation = activation\n\n    def __str__(self):\n        return render_object(self, [\"_axis\", \"activation\"])\n\n    def __call__(self, y: TensorLike) -&gt; TensorLike:\n        self._assert_cut_contains_only_one_tensor(y)\n\n        if self.activation is not None:\n            if isinstance(self.activation, str):\n                self.activation = self.activation.lower()\n                if self.activation in ['sigmoid', 'softmax']:\n                    y = getattr(get_backend(), self.activation)(y)\n\n                else:\n                    raise NotImplementedError(\n                        'This activation function is not currently supported '\n                        'by the backend'\n                    )\n            else:\n                y = self.activation(y)\n\n        return get_backend().max(y, axis=self._axis)\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.MaxClassQoI.__init__","title":"<code>__init__(axis=1, activation=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>axis</code> <code>int</code> <p>Output dimension over which max operation is taken.</p> <code>1</code> <code>activation</code> <code>Union[Callable, str, None]</code> <p>Activation function to be applied to the output before taking  the max. If <code>activation</code> is a string, use the corresponding  named activation function implemented by the backend. The  following strings are currently supported as shorthands for the respective standard activation functions:</p> <ul> <li><code>'sigmoid'</code> </li> <li><code>'softmax'</code> </li> </ul> <p>If <code>activation</code> is <code>None</code>, no activation function is applied to the input.</p> <code>None</code> Source code in <code>trulens/nn/quantities.py</code> <pre><code>def __init__(\n    self, axis: int = 1, activation: Union[Callable, str, None] = None\n):\n\"\"\"\n    Parameters:\n        axis:\n            Output dimension over which max operation is taken.\n\n        activation:\n            Activation function to be applied to the output before taking \n            the max. If `activation` is a string, use the corresponding \n            named activation function implemented by the backend. The \n            following strings are currently supported as shorthands for the\n            respective standard activation functions:\n\n            - `'sigmoid'` \n            - `'softmax'` \n\n            If `activation` is `None`, no activation function is applied to\n            the input.\n    \"\"\"\n    self._axis = axis\n    self.activation = activation\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.QoI","title":"<code>QoI</code>","text":"<p>         Bases: <code>AbstractBaseClass</code></p> <p>Interface for quantities of interest. The Quantity of Interest (QoI) is a function of the output specified by the slice that determines the network  output behavior that the attributions describe.</p> Source code in <code>trulens/nn/quantities.py</code> <pre><code>class QoI(AbstractBaseClass):\n\"\"\"\n    Interface for quantities of interest. The *Quantity of Interest* (QoI) is a\n    function of the output specified by the slice that determines the network \n    output behavior that the attributions describe.\n    \"\"\"\n\n    def __str__(self):\n        return render_object(self, [])\n\n    # TODO: Need to give a seperate value of y at target instance here since\n    # these are values are interventions. Cannot presently define a QoI that says:\n    # logits of the predicted class for each instance.\n    # Issue GH-72 . Task MLNN-415 .\n\n    def _wrap_public_call(self, y: Outputs[Tensor]) -&gt; Outputs[Tensor]:\n\"\"\"\n        Wrap a public call that may result in one or more tensors. Signature of\n        this class is not specific while public calls are flexible.\n        \"\"\"\n\n        return many_of_om(self.__call__(om_of_many(y)))\n\n    @abstractmethod\n    def __call__(self, y: OM[Outputs, Tensor]) -&gt; OM[Outputs, Tensor]:\n\"\"\"\n        Computes the distribution of interest from an initial point.\n\n        Parameters:\n            y:\n                Output point from which the quantity is derived. Must be a\n                differentiable tensor.\n\n        Returns:\n            A differentiable batched scalar tensor representing the QoI.\n        \"\"\"\n        raise NotImplementedError\n\n    def _assert_cut_contains_only_one_tensor(self, x):\n        if isinstance(x, DATA_CONTAINER_TYPE):\n            raise QoiCutSupportError(\n                'Cut provided to quantity of interest was comprised of '\n                'multiple tensors, but `{}` is only defined for cuts comprised '\n                'of a single tensor (received a list of {} tensors).\\n'\n                '\\n'\n                'Either (1) select a slice where the `to_cut` corresponds to a '\n                'single tensor, or (2) implement/use a `QoI` object that '\n                'supports lists of tensors, i.e., where the parameter, `x`, to '\n                '`__call__` is expected/allowed to be a list of {} tensors.'.\n                format(self.__class__.__name__, len(x), len(x))\n            )\n\n        elif not get_backend().is_tensor(x):\n            raise ValueError(\n                '`{}` expected to receive an instance of `Tensor`, but '\n                'received an instance of {}'.format(\n                    self.__class__.__name__, type(x)\n                )\n            )\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.QoI.__call__","title":"<code>__call__(y)</code>  <code>abstractmethod</code>","text":"<p>Computes the distribution of interest from an initial point.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>OM[Outputs, Tensor]</code> <p>Output point from which the quantity is derived. Must be a differentiable tensor.</p> required <p>Returns:</p> Type Description <code>OM[Outputs, Tensor]</code> <p>A differentiable batched scalar tensor representing the QoI.</p> Source code in <code>trulens/nn/quantities.py</code> <pre><code>@abstractmethod\ndef __call__(self, y: OM[Outputs, Tensor]) -&gt; OM[Outputs, Tensor]:\n\"\"\"\n    Computes the distribution of interest from an initial point.\n\n    Parameters:\n        y:\n            Output point from which the quantity is derived. Must be a\n            differentiable tensor.\n\n    Returns:\n        A differentiable batched scalar tensor representing the QoI.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.QoiCutSupportError","title":"<code>QoiCutSupportError</code>","text":"<p>         Bases: <code>ValueError</code></p> <p>Exception raised if the quantity of interest is called on a cut whose output is not supported by the quantity of interest.</p> Source code in <code>trulens/nn/quantities.py</code> <pre><code>class QoiCutSupportError(ValueError):\n\"\"\"\n    Exception raised if the quantity of interest is called on a cut whose output\n    is not supported by the quantity of interest.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.ThresholdQoI","title":"<code>ThresholdQoI</code>","text":"<p>         Bases: <code>QoI</code></p> <p>Quantity of interest for attributing network output toward the difference  between two regions seperated by a given threshold. I.e., the quantity of interest is the \"high\" elements minus the \"low\" elements, where the high elements have activations above the threshold and the low elements have  activations below the threshold.</p> <p>Use case: bianry segmentation.</p> Source code in <code>trulens/nn/quantities.py</code> <pre><code>class ThresholdQoI(QoI):\n\"\"\"\n    Quantity of interest for attributing network output toward the difference \n    between two regions seperated by a given threshold. I.e., the quantity of\n    interest is the \"high\" elements minus the \"low\" elements, where the high\n    elements have activations above the threshold and the low elements have \n    activations below the threshold.\n\n    Use case: bianry segmentation.\n    \"\"\"\n\n    def __init__(\n        self,\n        threshold: float,\n        low_minus_high: bool = False,\n        activation: Union[Callable, str, None] = None\n    ):\n\"\"\"\n        Parameters:\n            threshold:\n                A threshold to determine the element-wise sign of the input \n                tensor. The elements with activations higher than the threshold \n                will retain their sign, while the elements with activations \n                lower than the threshold will have their sign flipped (or vice \n                versa if `low_minus_high` is set to `True`).\n            low_minus_high:\n                If `True`, substract the output with activations above the \n                threshold from the output with activations below the threshold. \n                If `False`, substract the output with activations below the \n                threshold from the output with activations above the threshold.\n            activation: str or function, optional\n                Activation function to be applied to the quantity before taking\n                the threshold. If `activation` is a string, use the \n                corresponding activation function implemented by the backend \n                (currently supported: `'sigmoid'` and `'softmax'`). Otherwise, \n                if `activation` is not `None`, it will be treated as a callable.\n                If `activation` is `None`, do not apply an activation function \n                to the quantity.\n        \"\"\"\n        # TODO(klas):should this support an aggregation function? By default\n        #   this is a sum, but it could, for example, subtract the greatest\n        #   positive element from the least negative element.\n        self.threshold = threshold\n        self.low_minus_high = low_minus_high\n        self.activation = activation\n\n    def __call__(self, x: TensorLike) -&gt; TensorLike:\n        B = get_backend()\n        self._assert_cut_contains_only_one_tensor(x)\n\n        if self.activation is not None:\n            if isinstance(self.activation, str):\n                self.activation = self.activation.lower()\n                if self.activation in ['sigmoid', 'softmax']:\n                    x = getattr(B, self.activation)(x)\n                else:\n                    raise NotImplementedError(\n                        'This activation function is not currently supported '\n                        'by the backend'\n                    )\n            else:\n                x = self.activation(x)\n\n        # TODO(klas): is the `clone` necessary here? Not sure why it was\n        #   included.\n        mask = B.sign(B.clone(x) - self.threshold)\n        if self.low_minus_high:\n            mask = -mask\n\n        non_batch_dimensions = tuple(range(len(B.int_shape(x)))[1:])\n\n        return B.sum(mask * x, axis=non_batch_dimensions)\n</code></pre>"},{"location":"api/quantities/#trulens.nn.quantities.ThresholdQoI.__init__","title":"<code>__init__(threshold, low_minus_high=False, activation=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>A threshold to determine the element-wise sign of the input  tensor. The elements with activations higher than the threshold  will retain their sign, while the elements with activations  lower than the threshold will have their sign flipped (or vice  versa if <code>low_minus_high</code> is set to <code>True</code>).</p> required <code>low_minus_high</code> <code>bool</code> <p>If <code>True</code>, substract the output with activations above the  threshold from the output with activations below the threshold.  If <code>False</code>, substract the output with activations below the  threshold from the output with activations above the threshold.</p> <code>False</code> <code>activation</code> <code>Union[Callable, str, None]</code> <p>str or function, optional Activation function to be applied to the quantity before taking the threshold. If <code>activation</code> is a string, use the  corresponding activation function implemented by the backend  (currently supported: <code>'sigmoid'</code> and <code>'softmax'</code>). Otherwise,  if <code>activation</code> is not <code>None</code>, it will be treated as a callable. If <code>activation</code> is <code>None</code>, do not apply an activation function  to the quantity.</p> <code>None</code> Source code in <code>trulens/nn/quantities.py</code> <pre><code>def __init__(\n    self,\n    threshold: float,\n    low_minus_high: bool = False,\n    activation: Union[Callable, str, None] = None\n):\n\"\"\"\n    Parameters:\n        threshold:\n            A threshold to determine the element-wise sign of the input \n            tensor. The elements with activations higher than the threshold \n            will retain their sign, while the elements with activations \n            lower than the threshold will have their sign flipped (or vice \n            versa if `low_minus_high` is set to `True`).\n        low_minus_high:\n            If `True`, substract the output with activations above the \n            threshold from the output with activations below the threshold. \n            If `False`, substract the output with activations below the \n            threshold from the output with activations above the threshold.\n        activation: str or function, optional\n            Activation function to be applied to the quantity before taking\n            the threshold. If `activation` is a string, use the \n            corresponding activation function implemented by the backend \n            (currently supported: `'sigmoid'` and `'softmax'`). Otherwise, \n            if `activation` is not `None`, it will be treated as a callable.\n            If `activation` is `None`, do not apply an activation function \n            to the quantity.\n    \"\"\"\n    # TODO(klas):should this support an aggregation function? By default\n    #   this is a sum, but it could, for example, subtract the greatest\n    #   positive element from the least negative element.\n    self.threshold = threshold\n    self.low_minus_high = low_minus_high\n    self.activation = activation\n</code></pre>"},{"location":"api/slices/","title":"Slices","text":"<p>The slice, or layer, of the network provides flexibility over the level of  abstraction for the explanation. In a low layer, an explanation may highlight  the edges that were most important in identifying an object like a face, while  in a higher layer, the explanation might highlight high-level features such as a nose or mouth. By raising the level of abstraction, explanations that generalize over larger sets of samples are possible.</p> <p>Formally, A network, \\(f\\), can be broken into a slice, \\(f = g \\circ h\\), where  \\(h\\) can be thought of as a pre-processor that computes features, and \\(g\\) can be thought of as a sub-model that uses the features computed by \\(h\\).</p>"},{"location":"api/slices/#trulens.nn.slices.Cut","title":"<code>Cut</code>","text":"<p>         Bases: <code>object</code></p> <p>A cut is the primary building block for a slice. It determines an internal component of a network to expose. A slice if formed by two cuts.</p> Source code in <code>trulens/nn/slices.py</code> <pre><code>class Cut(object):\n\"\"\"\n    A cut is the primary building block for a slice. It determines an internal\n    component of a network to expose. A slice if formed by two cuts.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: LayerIdentifier,\n        anchor: str = 'out',\n        accessor: Optional[Callable] = None\n    ):\n\"\"\"\n        Parameters:\n            name:\n                The name or index of a layer in the model, or a list containing\n                the names/indices of mutliple layers.\n\n            anchor: \n                Determines whether input (`'in'`) or the output (`'out'`) tensor\n                of the spcified layer should be used.\n\n            accessor:\n                An accessor function that operates on the layer, mapping the \n                tensor (or list thereof) corresponding to the layer's \n                input/output to another tensor (or list thereof). This can be \n                used to, e.g., extract a particular output from a layer that \n                produces a sequence of outputs. If `accessor` is `None`, the \n                following accessor function will be used: \n                ```python\n                lambda t: t[-1] if isinstance(t, list) else t\n                ```\n        \"\"\"\n        assert name is None or isinstance(\n            name, (list, int, str)\n        ), \"Cut.name must be one of: layer index, layer name, or list of names/indices of multiple layers\"\n        if isinstance(name, list):\n            for n in name:\n                assert isinstance(\n                    n, (int, str)\n                ), f\"Elements in Cut.name must be layer names (str) or indices (int). Got type {type(n)}\"\n        anchor = str(anchor)\n        assert anchor in [\n            'in', 'out'\n        ], \"Cut.anchor must be one of ('in', 'out')\"\n        assert accessor is None or isinstance(\n            accessor, Callable\n        ), \"Cut.accessor must be callable or None\"\n\n        if get_backend().backend == 'pytorch':\n            if (isinstance(name, int) or\n                (isinstance(name, list) and isinstance(name[0], int))):\n\n                tru_logger.warning(\n                    '\\n\\nPytorch does not have native support for indexed '\n                    'layers. Using layer indices is not recommended.\\n'\n                )\n\n        self.name = name\n        self.accessor = accessor\n        self.anchor = anchor\n\n    def __str__(self):\n        return render_object(self, ['name', 'accessor', 'anchor'])\n\n    # TODO: layer arg might need to be more specific\n    def access_layer(self, layer: TensorLike) -&gt; TensorLike:\n\"\"\"\n        Applies `self.accessor` to the result of collecting the relevant \n        tensor(s) associated with a layer's output.\n\n        Parameters:\n            layer:\n                The tensor output (or input, if so specified by the anchor) of \n                the layer(s) specified by this cut.\n\n        Returns:\n            The result of applying `self.accessor` to the given layer.\n        \"\"\"\n        if layer is None:\n            return layer\n        elif self.accessor is None:\n            return layer\n        else:\n            layer = (\n                layer[0]\n                if isinstance(layer, list) and len(layer) == 1 else layer\n            )\n            return self.accessor(layer)\n</code></pre>"},{"location":"api/slices/#trulens.nn.slices.Cut.__init__","title":"<code>__init__(name, anchor='out', accessor=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>LayerIdentifier</code> <p>The name or index of a layer in the model, or a list containing the names/indices of mutliple layers.</p> required <code>anchor</code> <code>str</code> <p>Determines whether input (<code>'in'</code>) or the output (<code>'out'</code>) tensor of the spcified layer should be used.</p> <code>'out'</code> <code>accessor</code> <code>Optional[Callable]</code> <p>An accessor function that operates on the layer, mapping the  tensor (or list thereof) corresponding to the layer's  input/output to another tensor (or list thereof). This can be  used to, e.g., extract a particular output from a layer that  produces a sequence of outputs. If <code>accessor</code> is <code>None</code>, the  following accessor function will be used:  <pre><code>lambda t: t[-1] if isinstance(t, list) else t\n</code></pre></p> <code>None</code> Source code in <code>trulens/nn/slices.py</code> <pre><code>def __init__(\n    self,\n    name: LayerIdentifier,\n    anchor: str = 'out',\n    accessor: Optional[Callable] = None\n):\n\"\"\"\n    Parameters:\n        name:\n            The name or index of a layer in the model, or a list containing\n            the names/indices of mutliple layers.\n\n        anchor: \n            Determines whether input (`'in'`) or the output (`'out'`) tensor\n            of the spcified layer should be used.\n\n        accessor:\n            An accessor function that operates on the layer, mapping the \n            tensor (or list thereof) corresponding to the layer's \n            input/output to another tensor (or list thereof). This can be \n            used to, e.g., extract a particular output from a layer that \n            produces a sequence of outputs. If `accessor` is `None`, the \n            following accessor function will be used: \n            ```python\n            lambda t: t[-1] if isinstance(t, list) else t\n            ```\n    \"\"\"\n    assert name is None or isinstance(\n        name, (list, int, str)\n    ), \"Cut.name must be one of: layer index, layer name, or list of names/indices of multiple layers\"\n    if isinstance(name, list):\n        for n in name:\n            assert isinstance(\n                n, (int, str)\n            ), f\"Elements in Cut.name must be layer names (str) or indices (int). Got type {type(n)}\"\n    anchor = str(anchor)\n    assert anchor in [\n        'in', 'out'\n    ], \"Cut.anchor must be one of ('in', 'out')\"\n    assert accessor is None or isinstance(\n        accessor, Callable\n    ), \"Cut.accessor must be callable or None\"\n\n    if get_backend().backend == 'pytorch':\n        if (isinstance(name, int) or\n            (isinstance(name, list) and isinstance(name[0], int))):\n\n            tru_logger.warning(\n                '\\n\\nPytorch does not have native support for indexed '\n                'layers. Using layer indices is not recommended.\\n'\n            )\n\n    self.name = name\n    self.accessor = accessor\n    self.anchor = anchor\n</code></pre>"},{"location":"api/slices/#trulens.nn.slices.Cut.access_layer","title":"<code>access_layer(layer)</code>","text":"<p>Applies <code>self.accessor</code> to the result of collecting the relevant  tensor(s) associated with a layer's output.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>TensorLike</code> <p>The tensor output (or input, if so specified by the anchor) of  the layer(s) specified by this cut.</p> required <p>Returns:</p> Type Description <code>TensorLike</code> <p>The result of applying <code>self.accessor</code> to the given layer.</p> Source code in <code>trulens/nn/slices.py</code> <pre><code>def access_layer(self, layer: TensorLike) -&gt; TensorLike:\n\"\"\"\n    Applies `self.accessor` to the result of collecting the relevant \n    tensor(s) associated with a layer's output.\n\n    Parameters:\n        layer:\n            The tensor output (or input, if so specified by the anchor) of \n            the layer(s) specified by this cut.\n\n    Returns:\n        The result of applying `self.accessor` to the given layer.\n    \"\"\"\n    if layer is None:\n        return layer\n    elif self.accessor is None:\n        return layer\n    else:\n        layer = (\n            layer[0]\n            if isinstance(layer, list) and len(layer) == 1 else layer\n        )\n        return self.accessor(layer)\n</code></pre>"},{"location":"api/slices/#trulens.nn.slices.InputCut","title":"<code>InputCut</code>","text":"<p>         Bases: <code>Cut</code></p> <p>Special cut that selects the input(s) of a model.</p> Source code in <code>trulens/nn/slices.py</code> <pre><code>class InputCut(Cut):\n\"\"\"\n    Special cut that selects the input(s) of a model.\n    \"\"\"\n\n    def __init__(self, anchor: str = 'in', accessor: Optional[Callable] = None):\n\"\"\"\n        Parameters:\n            anchor: \n                Determines whether input (`'in'`) or the output (`'out'`) tensor\n                of the spcified layer should be used.\n\n            accessor:\n                An accessor function that operates on the layer, mapping the \n                tensor (or list thereof) corresponding to the layer's \n                input/output to another tensor (or list thereof). This can be \n                used to, e.g., extract a particular output from a layer that \n                produces a sequence of outputs. If `accessor` is `None`, the \n                following accessor function will be used: \n                ```python\n                lambda t: t[-1] if isinstance(t, list) else t\n                ```\n        \"\"\"\n        super().__init__(None, anchor, accessor)\n</code></pre>"},{"location":"api/slices/#trulens.nn.slices.InputCut.__init__","title":"<code>__init__(anchor='in', accessor=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>anchor</code> <code>str</code> <p>Determines whether input (<code>'in'</code>) or the output (<code>'out'</code>) tensor of the spcified layer should be used.</p> <code>'in'</code> <code>accessor</code> <code>Optional[Callable]</code> <p>An accessor function that operates on the layer, mapping the  tensor (or list thereof) corresponding to the layer's  input/output to another tensor (or list thereof). This can be  used to, e.g., extract a particular output from a layer that  produces a sequence of outputs. If <code>accessor</code> is <code>None</code>, the  following accessor function will be used:  <pre><code>lambda t: t[-1] if isinstance(t, list) else t\n</code></pre></p> <code>None</code> Source code in <code>trulens/nn/slices.py</code> <pre><code>def __init__(self, anchor: str = 'in', accessor: Optional[Callable] = None):\n\"\"\"\n    Parameters:\n        anchor: \n            Determines whether input (`'in'`) or the output (`'out'`) tensor\n            of the spcified layer should be used.\n\n        accessor:\n            An accessor function that operates on the layer, mapping the \n            tensor (or list thereof) corresponding to the layer's \n            input/output to another tensor (or list thereof). This can be \n            used to, e.g., extract a particular output from a layer that \n            produces a sequence of outputs. If `accessor` is `None`, the \n            following accessor function will be used: \n            ```python\n            lambda t: t[-1] if isinstance(t, list) else t\n            ```\n    \"\"\"\n    super().__init__(None, anchor, accessor)\n</code></pre>"},{"location":"api/slices/#trulens.nn.slices.LogitCut","title":"<code>LogitCut</code>","text":"<p>         Bases: <code>Cut</code></p> <p>Special cut that selects the logit layer of a model. The logit layer must be named <code>'logits'</code> or otherwise specified by the user to the model wrapper.</p> Source code in <code>trulens/nn/slices.py</code> <pre><code>class LogitCut(Cut):\n\"\"\"\n    Special cut that selects the logit layer of a model. The logit layer must be\n    named `'logits'` or otherwise specified by the user to the model wrapper.\n    \"\"\"\n\n    def __init__(\n        self, anchor: str = 'out', accessor: Optional[Callable] = None\n    ):\n\"\"\"\n        Parameters:\n            anchor: \n                Determines whether input (`'in'`) or the output (`'out'`) tensor\n                of the spcified layer should be used.\n\n            accessor:\n                An accessor function that operates on the layer, mapping the \n                tensor (or list thereof) corresponding to the layer's \n                input/output to another tensor (or list thereof). This can be \n                used to, e.g., extract a particular output from a layer that \n                produces a sequence of outputs. If `accessor` is `None`, the \n                following accessor function will be used: \n                ```python\n                lambda t: t[-1] if isinstance(t, list) else t\n                ```\n        \"\"\"\n        super(LogitCut, self).__init__(None, anchor, accessor)\n</code></pre>"},{"location":"api/slices/#trulens.nn.slices.LogitCut.__init__","title":"<code>__init__(anchor='out', accessor=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>anchor</code> <code>str</code> <p>Determines whether input (<code>'in'</code>) or the output (<code>'out'</code>) tensor of the spcified layer should be used.</p> <code>'out'</code> <code>accessor</code> <code>Optional[Callable]</code> <p>An accessor function that operates on the layer, mapping the  tensor (or list thereof) corresponding to the layer's  input/output to another tensor (or list thereof). This can be  used to, e.g., extract a particular output from a layer that  produces a sequence of outputs. If <code>accessor</code> is <code>None</code>, the  following accessor function will be used:  <pre><code>lambda t: t[-1] if isinstance(t, list) else t\n</code></pre></p> <code>None</code> Source code in <code>trulens/nn/slices.py</code> <pre><code>def __init__(\n    self, anchor: str = 'out', accessor: Optional[Callable] = None\n):\n\"\"\"\n    Parameters:\n        anchor: \n            Determines whether input (`'in'`) or the output (`'out'`) tensor\n            of the spcified layer should be used.\n\n        accessor:\n            An accessor function that operates on the layer, mapping the \n            tensor (or list thereof) corresponding to the layer's \n            input/output to another tensor (or list thereof). This can be \n            used to, e.g., extract a particular output from a layer that \n            produces a sequence of outputs. If `accessor` is `None`, the \n            following accessor function will be used: \n            ```python\n            lambda t: t[-1] if isinstance(t, list) else t\n            ```\n    \"\"\"\n    super(LogitCut, self).__init__(None, anchor, accessor)\n</code></pre>"},{"location":"api/slices/#trulens.nn.slices.OutputCut","title":"<code>OutputCut</code>","text":"<p>         Bases: <code>Cut</code></p> <p>Special cut that selects the output(s) of a model.</p> Source code in <code>trulens/nn/slices.py</code> <pre><code>class OutputCut(Cut):\n\"\"\"\n    Special cut that selects the output(s) of a model.\n    \"\"\"\n\n    def __init__(\n        self, anchor: str = 'out', accessor: Optional[Callable] = None\n    ):\n\"\"\"\n        Parameters:\n            anchor: \n                Determines whether input (`'in'`) or the output (`'out'`) tensor\n                of the spcified layer should be used.\n\n            accessor:\n                An accessor function that operates on the layer, mapping the \n                tensor (or list thereof) corresponding to the layer's \n                input/output to another tensor (or list thereof). This can be \n                used to, e.g., extract a particular output from a layer that \n                produces a sequence of outputs. If `accessor` is `None`, the \n                following accessor function will be used: \n                ```python\n                lambda t: t[-1] if isinstance(t, list) else t\n                ```\n        \"\"\"\n        super(OutputCut, self).__init__(None, anchor, accessor)\n</code></pre>"},{"location":"api/slices/#trulens.nn.slices.OutputCut.__init__","title":"<code>__init__(anchor='out', accessor=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>anchor</code> <code>str</code> <p>Determines whether input (<code>'in'</code>) or the output (<code>'out'</code>) tensor of the spcified layer should be used.</p> <code>'out'</code> <code>accessor</code> <code>Optional[Callable]</code> <p>An accessor function that operates on the layer, mapping the  tensor (or list thereof) corresponding to the layer's  input/output to another tensor (or list thereof). This can be  used to, e.g., extract a particular output from a layer that  produces a sequence of outputs. If <code>accessor</code> is <code>None</code>, the  following accessor function will be used:  <pre><code>lambda t: t[-1] if isinstance(t, list) else t\n</code></pre></p> <code>None</code> Source code in <code>trulens/nn/slices.py</code> <pre><code>def __init__(\n    self, anchor: str = 'out', accessor: Optional[Callable] = None\n):\n\"\"\"\n    Parameters:\n        anchor: \n            Determines whether input (`'in'`) or the output (`'out'`) tensor\n            of the spcified layer should be used.\n\n        accessor:\n            An accessor function that operates on the layer, mapping the \n            tensor (or list thereof) corresponding to the layer's \n            input/output to another tensor (or list thereof). This can be \n            used to, e.g., extract a particular output from a layer that \n            produces a sequence of outputs. If `accessor` is `None`, the \n            following accessor function will be used: \n            ```python\n            lambda t: t[-1] if isinstance(t, list) else t\n            ```\n    \"\"\"\n    super(OutputCut, self).__init__(None, anchor, accessor)\n</code></pre>"},{"location":"api/slices/#trulens.nn.slices.Slice","title":"<code>Slice</code>","text":"<p>         Bases: <code>object</code></p> <p>Class representing a slice of a network. A network, \\(f\\), can be broken into a slice, \\(f = g \\circ h\\), where \\(h\\) can be thought of as a  pre-processor that computes features, and \\(g\\) can be thought of as a  sub-model that uses the features computed by \\(h\\).</p> <p>A <code>Slice</code> object represents a slice as two <code>Cut</code>s, <code>from_cut</code> and <code>to_cut</code>, which are the layers corresponding to the output of \\(h\\) and \\(g\\),  respectively.</p> Source code in <code>trulens/nn/slices.py</code> <pre><code>class Slice(object):\n\"\"\"\n    Class representing a slice of a network. A network, $f$, can be broken\n    into a slice, $f = g \\\\circ h$, where $h$ can be thought of as a \n    pre-processor that computes features, and $g$ can be thought of as a \n    sub-model that uses the features computed by $h$.\n\n    A `Slice` object represents a slice as two `Cut`s, `from_cut` and `to_cut`,\n    which are the layers corresponding to the output of $h$ and $g$, \n    respectively.\n    \"\"\"\n\n    def __init__(self, from_cut: Cut, to_cut: Cut):\n\"\"\"\n        Parameters:\n            from_cut:\n                Cut representing the output of the preprocessing function, $h$,\n                in slice, $f = g \\\\circ h$.\n\n            to_cut:\n                Cut representing the output of the sub-model, $g$, in slice, \n                $f = g \\\\circ h$.\n        \"\"\"\n        self._from_cut = from_cut\n        self._to_cut = to_cut\n\n    @property\n    def from_cut(self) -&gt; Cut:\n\"\"\"\n        Cut representing the output of the preprocessing function, $h$, in \n        slice, $f = g \\\\circ h$.\n        \"\"\"\n        return self._from_cut\n\n    @property\n    def to_cut(self) -&gt; Cut:\n\"\"\"\n        Cut representing the output of the sub-model, $g$, in slice, \n        $f = g \\\\circ h$.\n        \"\"\"\n        return self._to_cut\n\n    @staticmethod\n    def full_network():\n\"\"\"\n        Returns\n        -------\n        Slice\n            A slice representing the entire model, i.e., :math:`f = g \\\\circ h`,\n            where :math:`h` is the identity function and :math:`g = f`.\n        \"\"\"\n        return Slice(InputCut(), OutputCut())\n</code></pre>"},{"location":"api/slices/#trulens.nn.slices.Slice.from_cut","title":"<code>from_cut: Cut</code>  <code>property</code>","text":"<p>Cut representing the output of the preprocessing function, \\(h\\), in  slice, \\(f = g \\circ h\\).</p>"},{"location":"api/slices/#trulens.nn.slices.Slice.to_cut","title":"<code>to_cut: Cut</code>  <code>property</code>","text":"<p>Cut representing the output of the sub-model, \\(g\\), in slice,  \\(f = g \\circ h\\).</p>"},{"location":"api/slices/#trulens.nn.slices.Slice.__init__","title":"<code>__init__(from_cut, to_cut)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>from_cut</code> <code>Cut</code> <p>Cut representing the output of the preprocessing function, \\(h\\), in slice, \\(f = g \\circ h\\).</p> required <code>to_cut</code> <code>Cut</code> <p>Cut representing the output of the sub-model, \\(g\\), in slice,  \\(f = g \\circ h\\).</p> required Source code in <code>trulens/nn/slices.py</code> <pre><code>def __init__(self, from_cut: Cut, to_cut: Cut):\n\"\"\"\n    Parameters:\n        from_cut:\n            Cut representing the output of the preprocessing function, $h$,\n            in slice, $f = g \\\\circ h$.\n\n        to_cut:\n            Cut representing the output of the sub-model, $g$, in slice, \n            $f = g \\\\circ h$.\n    \"\"\"\n    self._from_cut = from_cut\n    self._to_cut = to_cut\n</code></pre>"},{"location":"api/slices/#trulens.nn.slices.Slice.full_network","title":"<code>full_network()</code>  <code>staticmethod</code>","text":""},{"location":"api/slices/#trulens.nn.slices.Slice.full_network--returns","title":"Returns","text":"<p>Slice     A slice representing the entire model, i.e., :math:<code>f = g \\circ h</code>,     where :math:<code>h</code> is the identity function and :math:<code>g = f</code>.</p> Source code in <code>trulens/nn/slices.py</code> <pre><code>@staticmethod\ndef full_network():\n\"\"\"\n    Returns\n    -------\n    Slice\n        A slice representing the entire model, i.e., :math:`f = g \\\\circ h`,\n        where :math:`h` is the identity function and :math:`g = f`.\n    \"\"\"\n    return Slice(InputCut(), OutputCut())\n</code></pre>"},{"location":"api/visualizations/","title":"Visualization Methods","text":"<p>One clear use case for measuring attributions is for human consumption. In order to be fully leveraged by humans, explanations need to be interpretable \u2014 a large vector of numbers doesn\u2019t in general make us more confident we understand what a network is doing. We therefore view an explanation as comprised of both an attribution measurement and an interpretation of what the attribution  values represent.</p> <p>One obvious way to interpret attributions, particularly in the image domain, is via visualization. This module provides several visualization methods for interpreting attributions as images.</p>"},{"location":"api/visualizations/#trulens.visualizations.ChannelMaskVisualizer","title":"<code>ChannelMaskVisualizer</code>","text":"<p>         Bases: <code>object</code></p> <p>Uses internal influence to visualize the pixels that are most salient towards a particular internal channel or neuron.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>class ChannelMaskVisualizer(object):\n\"\"\"\n    Uses internal influence to visualize the pixels that are most salient\n    towards a particular internal channel or neuron.\n    \"\"\"\n\n    def __init__(\n        self,\n        model,\n        layer,\n        channel,\n        channel_axis=None,\n        agg_fn=None,\n        doi=None,\n        blur=None,\n        threshold=0.5,\n        masked_opacity=0.2,\n        combine_channels: bool = True,\n        use_attr_as_opacity=None,\n        positive_only=None\n    ):\n\"\"\"\n        Configures the default parameters for the `__call__` method (these can \n        be overridden by passing in values to `__call__`).\n\n        Parameters:\n            model:\n                The wrapped model whose channel we're visualizing.\n\n            layer:\n                The identifier (either index or name) of the layer in which the \n                channel we're visualizing resides.\n\n            channel:\n                Index of the channel (for convolutional layers) or internal \n                neuron (for fully-connected layers) that we'd like to visualize.\n\n            channel_axis:\n                If different from the channel axis specified by the backend, the\n                supplied `channel_axis` will be used if operating on a \n                convolutional layer with 4-D image format.\n\n            agg_fn:\n                Function with which to aggregate the remaining dimensions \n                (except the batch dimension) in order to get a single scalar \n                value for each channel; If `None`, a sum over each neuron in the\n                channel will be taken. This argument is not used when the \n                channels are scalars, e.g., for dense layers.\n\n            doi:\n                The distribution of interest to use when computing the input\n                attributions towards the specified channel. If `None`, \n                `PointDoI` will be used.\n\n            blur:\n                Gives the radius of a Gaussian blur to be applied to the \n                attributions before visualizing. This can be used to help focus\n                on salient regions rather than specific salient pixels.\n\n            threshold:\n                Value in the range [0, 1]. Attribution values at or  below the \n                percentile given by `threshold` (after normalization, blurring,\n                etc.) will be masked.\n\n            masked_opacity: \n                Value in the range [0, 1] specifying the opacity for the parts\n                of the image that are masked.\n\n            combine_channels:\n                If `True`, the attributions will be averaged across the channel\n                dimension, resulting in a 1-channel attribution map.\n\n            use_attr_as_opacity:\n                If `True`, instead of using `threshold` and `masked_opacity`,\n                the opacity of each pixel is given by the 0-1-normalized \n                attribution value.\n\n            positive_only:\n                If `True`, only pixels with positive attribution will be \n                unmasked (or given nonzero opacity when `use_attr_as_opacity` is\n                true).\n        \"\"\"\n        B = get_backend()\n        if (B is not None and (channel_axis is None or channel_axis &lt; 0)):\n            channel_axis = B.channel_axis\n        elif (channel_axis is None or channel_axis &lt; 0):\n            channel_axis = 1\n\n        self.mask_visualizer = MaskVisualizer(\n            blur, threshold, masked_opacity, combine_channels,\n            use_attr_as_opacity, positive_only\n        )\n\n        self.infl_input = InternalInfluence(\n            model, (InputCut(), Cut(layer)),\n            InternalChannelQoI(channel, channel_axis, agg_fn),\n            PointDoi() if doi is None else doi\n        )\n\n    def __call__(\n        self,\n        x,\n        x_preprocessed=None,\n        output_file=None,\n        blur=None,\n        threshold=None,\n        masked_opacity=None,\n        combine_channels=None\n    ):\n\"\"\"\n        Visualizes the given attributions by overlaying an attribution heatmap \n        over the given image.\n\n        Parameters\n        ----------\n        attributions : numpy.ndarray\n            The attributions to visualize. Expected to be in 4-D image format.\n\n        x : numpy.ndarray\n            The original image(s) over which the attributions are calculated.\n            Must be the same shape as expected by the model used with this\n            visualizer.\n\n        x_preprocessed : numpy.ndarray, optional\n            If the model requires a preprocessed input (e.g., with the mean\n            subtracted) that is different from how the image should be \n            visualized, ``x_preprocessed`` should be specified. In this case \n            ``x`` will be used for visualization, and ``x_preprocessed`` will be\n            passed to the model when calculating attributions. Must be the same \n            shape as ``x``.\n\n        output_file : str, optional\n            If specified, the resulting visualization will be saved to a file\n            with the name given by ``output_file``.\n\n        blur : float, optional\n            If specified, gives the radius of a Gaussian blur to be applied to\n            the attributions before visualizing. This can be used to help focus\n            on salient regions rather than specific salient pixels. If None, \n            defaults to the value supplied to the constructor. Default None.\n\n        threshold : float\n            Value in the range [0, 1]. Attribution values at or  below the \n            percentile given by ``threshold`` will be masked. If None, defaults \n            to the value supplied to the constructor. Default None.\n\n        masked_opacity: float\n            Value in the range [0, 1] specifying the opacity for the parts of\n            the image that are masked. Default 0.2. If None, defaults to the \n            value supplied to the constructor. Default None.\n\n        combine_channels : bool\n            If True, the attributions will be averaged across the channel\n            dimension, resulting in a 1-channel attribution map. If None, \n            defaults to the value supplied to the constructor. Default None.\n        \"\"\"\n\n        attrs_input = self.infl_input.attributions(\n            x if x_preprocessed is None else x_preprocessed\n        )\n\n        return self.mask_visualizer(\n            attrs_input, x, output_file, blur, threshold, masked_opacity,\n            combine_channels\n        )\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.ChannelMaskVisualizer.__call__","title":"<code>__call__(x, x_preprocessed=None, output_file=None, blur=None, threshold=None, masked_opacity=None, combine_channels=None)</code>","text":"<p>Visualizes the given attributions by overlaying an attribution heatmap  over the given image.</p>"},{"location":"api/visualizations/#trulens.visualizations.ChannelMaskVisualizer.__call__--parameters","title":"Parameters","text":"numpy.ndarray <p>The attributions to visualize. Expected to be in 4-D image format.</p> numpy.ndarray <p>The original image(s) over which the attributions are calculated. Must be the same shape as expected by the model used with this visualizer.</p> numpy.ndarray, optional <p>If the model requires a preprocessed input (e.g., with the mean subtracted) that is different from how the image should be  visualized, <code>x_preprocessed</code> should be specified. In this case  <code>x</code> will be used for visualization, and <code>x_preprocessed</code> will be passed to the model when calculating attributions. Must be the same  shape as <code>x</code>.</p> str, optional <p>If specified, the resulting visualization will be saved to a file with the name given by <code>output_file</code>.</p> float, optional <p>If specified, gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If None,  defaults to the value supplied to the constructor. Default None.</p> float <p>Value in the range [0, 1]. Attribution values at or  below the  percentile given by <code>threshold</code> will be masked. If None, defaults  to the value supplied to the constructor. Default None.</p> float <p>Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. Default 0.2. If None, defaults to the  value supplied to the constructor. Default None.</p> bool <p>If True, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If None,  defaults to the value supplied to the constructor. Default None.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>def __call__(\n    self,\n    x,\n    x_preprocessed=None,\n    output_file=None,\n    blur=None,\n    threshold=None,\n    masked_opacity=None,\n    combine_channels=None\n):\n\"\"\"\n    Visualizes the given attributions by overlaying an attribution heatmap \n    over the given image.\n\n    Parameters\n    ----------\n    attributions : numpy.ndarray\n        The attributions to visualize. Expected to be in 4-D image format.\n\n    x : numpy.ndarray\n        The original image(s) over which the attributions are calculated.\n        Must be the same shape as expected by the model used with this\n        visualizer.\n\n    x_preprocessed : numpy.ndarray, optional\n        If the model requires a preprocessed input (e.g., with the mean\n        subtracted) that is different from how the image should be \n        visualized, ``x_preprocessed`` should be specified. In this case \n        ``x`` will be used for visualization, and ``x_preprocessed`` will be\n        passed to the model when calculating attributions. Must be the same \n        shape as ``x``.\n\n    output_file : str, optional\n        If specified, the resulting visualization will be saved to a file\n        with the name given by ``output_file``.\n\n    blur : float, optional\n        If specified, gives the radius of a Gaussian blur to be applied to\n        the attributions before visualizing. This can be used to help focus\n        on salient regions rather than specific salient pixels. If None, \n        defaults to the value supplied to the constructor. Default None.\n\n    threshold : float\n        Value in the range [0, 1]. Attribution values at or  below the \n        percentile given by ``threshold`` will be masked. If None, defaults \n        to the value supplied to the constructor. Default None.\n\n    masked_opacity: float\n        Value in the range [0, 1] specifying the opacity for the parts of\n        the image that are masked. Default 0.2. If None, defaults to the \n        value supplied to the constructor. Default None.\n\n    combine_channels : bool\n        If True, the attributions will be averaged across the channel\n        dimension, resulting in a 1-channel attribution map. If None, \n        defaults to the value supplied to the constructor. Default None.\n    \"\"\"\n\n    attrs_input = self.infl_input.attributions(\n        x if x_preprocessed is None else x_preprocessed\n    )\n\n    return self.mask_visualizer(\n        attrs_input, x, output_file, blur, threshold, masked_opacity,\n        combine_channels\n    )\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.ChannelMaskVisualizer.__init__","title":"<code>__init__(model, layer, channel, channel_axis=None, agg_fn=None, doi=None, blur=None, threshold=0.5, masked_opacity=0.2, combine_channels=True, use_attr_as_opacity=None, positive_only=None)</code>","text":"<p>Configures the default parameters for the <code>__call__</code> method (these can  be overridden by passing in values to <code>__call__</code>).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The wrapped model whose channel we're visualizing.</p> required <code>layer</code> <p>The identifier (either index or name) of the layer in which the  channel we're visualizing resides.</p> required <code>channel</code> <p>Index of the channel (for convolutional layers) or internal  neuron (for fully-connected layers) that we'd like to visualize.</p> required <code>channel_axis</code> <p>If different from the channel axis specified by the backend, the supplied <code>channel_axis</code> will be used if operating on a  convolutional layer with 4-D image format.</p> <code>None</code> <code>agg_fn</code> <p>Function with which to aggregate the remaining dimensions  (except the batch dimension) in order to get a single scalar  value for each channel; If <code>None</code>, a sum over each neuron in the channel will be taken. This argument is not used when the  channels are scalars, e.g., for dense layers.</p> <code>None</code> <code>doi</code> <p>The distribution of interest to use when computing the input attributions towards the specified channel. If <code>None</code>,  <code>PointDoI</code> will be used.</p> <code>None</code> <code>blur</code> <p>Gives the radius of a Gaussian blur to be applied to the  attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels.</p> <code>None</code> <code>threshold</code> <p>Value in the range [0, 1]. Attribution values at or  below the  percentile given by <code>threshold</code> (after normalization, blurring, etc.) will be masked.</p> <code>0.5</code> <code>masked_opacity</code> <p>Value in the range [0, 1] specifying the opacity for the parts of the image that are masked.</p> <code>0.2</code> <code>combine_channels</code> <code>bool</code> <p>If <code>True</code>, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map.</p> <code>True</code> <code>use_attr_as_opacity</code> <p>If <code>True</code>, instead of using <code>threshold</code> and <code>masked_opacity</code>, the opacity of each pixel is given by the 0-1-normalized  attribution value.</p> <code>None</code> <code>positive_only</code> <p>If <code>True</code>, only pixels with positive attribution will be  unmasked (or given nonzero opacity when <code>use_attr_as_opacity</code> is true).</p> <code>None</code> Source code in <code>trulens/visualizations.py</code> <pre><code>def __init__(\n    self,\n    model,\n    layer,\n    channel,\n    channel_axis=None,\n    agg_fn=None,\n    doi=None,\n    blur=None,\n    threshold=0.5,\n    masked_opacity=0.2,\n    combine_channels: bool = True,\n    use_attr_as_opacity=None,\n    positive_only=None\n):\n\"\"\"\n    Configures the default parameters for the `__call__` method (these can \n    be overridden by passing in values to `__call__`).\n\n    Parameters:\n        model:\n            The wrapped model whose channel we're visualizing.\n\n        layer:\n            The identifier (either index or name) of the layer in which the \n            channel we're visualizing resides.\n\n        channel:\n            Index of the channel (for convolutional layers) or internal \n            neuron (for fully-connected layers) that we'd like to visualize.\n\n        channel_axis:\n            If different from the channel axis specified by the backend, the\n            supplied `channel_axis` will be used if operating on a \n            convolutional layer with 4-D image format.\n\n        agg_fn:\n            Function with which to aggregate the remaining dimensions \n            (except the batch dimension) in order to get a single scalar \n            value for each channel; If `None`, a sum over each neuron in the\n            channel will be taken. This argument is not used when the \n            channels are scalars, e.g., for dense layers.\n\n        doi:\n            The distribution of interest to use when computing the input\n            attributions towards the specified channel. If `None`, \n            `PointDoI` will be used.\n\n        blur:\n            Gives the radius of a Gaussian blur to be applied to the \n            attributions before visualizing. This can be used to help focus\n            on salient regions rather than specific salient pixels.\n\n        threshold:\n            Value in the range [0, 1]. Attribution values at or  below the \n            percentile given by `threshold` (after normalization, blurring,\n            etc.) will be masked.\n\n        masked_opacity: \n            Value in the range [0, 1] specifying the opacity for the parts\n            of the image that are masked.\n\n        combine_channels:\n            If `True`, the attributions will be averaged across the channel\n            dimension, resulting in a 1-channel attribution map.\n\n        use_attr_as_opacity:\n            If `True`, instead of using `threshold` and `masked_opacity`,\n            the opacity of each pixel is given by the 0-1-normalized \n            attribution value.\n\n        positive_only:\n            If `True`, only pixels with positive attribution will be \n            unmasked (or given nonzero opacity when `use_attr_as_opacity` is\n            true).\n    \"\"\"\n    B = get_backend()\n    if (B is not None and (channel_axis is None or channel_axis &lt; 0)):\n        channel_axis = B.channel_axis\n    elif (channel_axis is None or channel_axis &lt; 0):\n        channel_axis = 1\n\n    self.mask_visualizer = MaskVisualizer(\n        blur, threshold, masked_opacity, combine_channels,\n        use_attr_as_opacity, positive_only\n    )\n\n    self.infl_input = InternalInfluence(\n        model, (InputCut(), Cut(layer)),\n        InternalChannelQoI(channel, channel_axis, agg_fn),\n        PointDoi() if doi is None else doi\n    )\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.HTML","title":"<code>HTML</code>","text":"<p>         Bases: <code>Output</code></p> <p>HTML visualization output format.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>class HTML(Output):\n\"\"\"HTML visualization output format.\"\"\"\n\n    def __init__(self):\n        try:\n            self.m_html = importlib.import_module(\"html\")\n        except:\n            raise ImportError(\n                \"HTML output requires html python module. Try 'pip install html'.\"\n            )\n\n    def blank(self):\n        return \"\"\n\n    def space(self):\n        return \"&amp;nbsp;\"\n\n    def escape(self, s):\n        return self.m_html.escape(s)\n\n    def linebreak(self):\n        return \"&lt;br/&gt;\"\n\n    def line(self, s):\n        return f\"&lt;span style='padding: 2px; margin: 2px; background: gray; border-radius: 4px;'&gt;{s}&lt;/span&gt;\"\n\n    def magnitude_colored(self, s, mag):\n        red = 0.0\n        green = 0.0\n        if mag &gt; 0:\n            green = 1.0  # 0.5 + mag * 0.5\n            red = 1.0 - mag * 0.5\n        else:\n            red = 1.0\n            green = 1.0 + mag * 0.5\n            #red = 0.5 - mag * 0.5\n\n        blue = min(red, green)\n        # blue = 1.0 - max(red, green)\n\n        return f\"&lt;span title='{mag:0.3f}' style='margin: 1px; padding: 1px; border-radius: 4px; background: black; color: rgb({red*255}, {green*255}, {blue*255});'&gt;{s}&lt;/span&gt;\"\n\n    def append(self, *pieces):\n        return ''.join(pieces)\n\n    def render(self, s):\n        return s\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.HeatmapVisualizer","title":"<code>HeatmapVisualizer</code>","text":"<p>         Bases: <code>Visualizer</code></p> <p>Visualizes attributions by overlaying an attribution heatmap over the original image, similar to how GradCAM visualizes attributions.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>class HeatmapVisualizer(Visualizer):\n\"\"\"\n    Visualizes attributions by overlaying an attribution heatmap over the\n    original image, similar to how GradCAM visualizes attributions.\n    \"\"\"\n\n    def __init__(\n        self,\n        overlay_opacity=0.5,\n        normalization_type=None,\n        blur=10.,\n        cmap='jet'\n    ):\n\"\"\"\n        Configures the default parameters for the `__call__` method (these can \n        be overridden by passing in values to `__call__`).\n\n        Parameters:\n            overlay_opacity: float\n                Value in the range [0, 1] specifying the opacity for the heatmap\n                overlay.\n\n            normalization_type:\n                Specifies one of the following configurations for normalizing\n                the attributions (each item is normalized separately):\n\n                - `'unsigned_max'`: normalizes the attributions to the range \n                  [-1, 1] by dividing the attributions by the maximum absolute \n                  attribution value.\n                - `'unsigned_max_positive_centered'`: same as above, but scales\n                  the values to the range [0, 1], with negative scores less than\n                  0.5 and positive scores greater than 0.5. \n                - `'magnitude_max'`: takes the absolute value of the \n                  attributions, then normalizes the attributions to the range \n                  [0, 1] by dividing by the maximum absolute attribution value.\n                - `'magnitude_sum'`: takes the absolute value of the \n                  attributions, then scales them such that they sum to 1. If \n                  this option is used, each channel is normalized separately, \n                  such that each channel sums to 1.\n                - `'signed_max'`: normalizes the attributions to the range \n                  [-1, 1] by dividing the positive values by the maximum \n                  positive attribution value and the negative values by the \n                  minimum negative attribution value.\n                - `'signed_max_positive_centered'`: same as above, but scales \n                  the values to the range [0, 1], with negative scores less than\n                  0.5 and positive scores greater than 0.5.\n                - `'signed_sum'`: scales the positive attributions such that \n                  they sum to 1 and the negative attributions such that they\n                  scale to -1. If this option is used, each channel is \n                  normalized separately.\n                - `'01'`: normalizes the attributions to the range [0, 1] by \n                  subtracting the minimum attribution value then dividing by the\n                  maximum attribution value.\n                - `'unnormalized'`: leaves the attributions unaffected.\n\n                If `None`, either `'unsigned_max'` (for single-channel data) or \n                `'unsigned_max_positive_centered'` (for multi-channel data) is\n                used.\n\n            blur:\n                Gives the radius of a Gaussian blur to be applied to the \n                attributions before visualizing. This can be used to help focus\n                on salient regions rather than specific salient pixels.\n\n            cmap: matplotlib.colors.Colormap | str, optional\n                Colormap or name of a Colormap to use for the visualization. If \n                `None`, the colormap will be chosen based on the normalization \n                type. This argument is only used for single-channel data\n                (including when `combine_channels` is True).\n        \"\"\"\n\n        super().__init__(\n            combine_channels=True,\n            normalization_type=normalization_type,\n            blur=blur,\n            cmap=cmap\n        )\n\n        self.default_overlay_opacity = overlay_opacity\n\n    def __call__(\n        self,\n        attributions,\n        x,\n        output_file=None,\n        imshow=True,\n        fig=None,\n        return_tiled=False,\n        overlay_opacity=None,\n        normalization_type=None,\n        blur=None,\n        cmap=None\n    ) -&gt; np.ndarray:\n\"\"\"\n        Visualizes the given attributions by overlaying an attribution heatmap \n        over the given image.\n\n        Parameters:\n            attributions:\n                A `np.ndarray` containing the attributions to be visualized.\n\n            x:\n                A `np.ndarray` of items in the same shape as `attributions`\n                corresponding to the records explained by the given \n                attributions. The visualization will be superimposed onto the\n                corresponding set of records.\n\n            output_file:\n                File name to save the visualization image to. If `None`, no\n                image will be saved, but the figure can still be displayed.\n\n            imshow:\n                If true, a the visualization will be displayed. Otherwise the\n                figure will not be displayed, but the figure can still be saved.\n\n            fig:\n                The `pyplot` figure to display the visualization in. If `None`,\n                a new figure will be created.\n\n            return_tiled:\n                If true, the returned array will be in the same shape as the\n                visualization, with no batch dimension and the samples in the\n                batch tiled along the width and height dimensions. If false, the\n                returned array will be reshaped to match `attributions`.\n\n            overlay_opacity: float\n                Value in the range [0, 1] specifying the opacity for the heatmap\n                overlay. If `None`, defaults to the value supplied to the \n                constructor.\n\n            normalization_type:\n                Specifies one of the following configurations for normalizing\n                the attributions (each item is normalized separately):\n\n                - `'unsigned_max'`: normalizes the attributions to the range \n                  [-1, 1] by dividing the attributions by the maximum absolute \n                  attribution value.\n                - `'unsigned_max_positive_centered'`: same as above, but scales\n                  the values to the range [0, 1], with negative scores less than\n                  0.5 and positive scores greater than 0.5. \n                - `'magnitude_max'`: takes the absolute value of the \n                  attributions, then normalizes the attributions to the range \n                  [0, 1] by dividing by the maximum absolute attribution value.\n                - `'magnitude_sum'`: takes the absolute value of the \n                  attributions, then scales them such that they sum to 1. If \n                  this option is used, each channel is normalized separately, \n                  such that each channel sums to 1.\n                - `'signed_max'`: normalizes the attributions to the range \n                  [-1, 1] by dividing the positive values by the maximum \n                  positive attribution value and the negative values by the \n                  minimum negative attribution value.\n                - `'signed_max_positive_centered'`: same as above, but scales \n                  the values to the range [0, 1], with negative scores less than\n                  0.5 and positive scores greater than 0.5.\n                - `'signed_sum'`: scales the positive attributions such that \n                  they sum to 1 and the negative attributions such that they\n                  scale to -1. If this option is used, each channel is \n                  normalized separately.\n                - `'01'`: normalizes the attributions to the range [0, 1] by \n                  subtracting the minimum attribution value then dividing by the\n                  maximum attribution value.\n                - `'unnormalized'`: leaves the attributions unaffected.\n\n                If `None`, defaults to the value supplied to the constructor.\n\n            blur:\n                Gives the radius of a Gaussian blur to be applied to the \n                attributions before visualizing. This can be used to help focus\n                on salient regions rather than specific salient pixels. If\n                `None`, defaults to the value supplied to the constructor.\n\n            cmap: matplotlib.colors.Colormap | str, optional\n                Colormap or name of a Colormap to use for the visualization. If\n                `None`, defaults to the value supplied to the constructor.\n\n        Returns:\n            A `np.ndarray` array of the numerical representation of the\n            attributions as modified for the visualization. This includes \n            normalization, blurring, etc.\n        \"\"\"\n        _, normalization_type, blur, cmap = self._check_args(\n            attributions, None, normalization_type, blur, cmap\n        )\n\n        # Combine the channels.\n        attributions = attributions.mean(\n            axis=get_backend().channel_axis, keepdims=True\n        )\n\n        # Blur the attributions so the explanation is smoother.\n        if blur:\n            attributions = self._blur(attributions, blur)\n\n        # Normalize the attributions.\n        attributions = self._normalize(attributions, normalization_type)\n\n        tiled_attributions = self.tiler.tile(attributions)\n\n        # Normalize the pixels to be in the range [0, 1].\n        x = self._normalize(x, '01')\n        tiled_x = self.tiler.tile(x)\n\n        if cmap is None:\n            cmap = self.default_cmap\n\n        if overlay_opacity is None:\n            overlay_opacity = self.default_overlay_opacity\n\n        # Display the figure:\n        _fig = plt.figure() if fig is None else fig\n\n        plt.axis('off')\n        plt.imshow(tiled_x)\n        plt.imshow(tiled_attributions, alpha=overlay_opacity, cmap=cmap)\n\n        if output_file:\n            plt.savefig(output_file, bbox_inches=0)\n\n        if imshow:\n            plt.show()\n\n        elif fig is None:\n            plt.close(_fig)\n\n        return tiled_attributions if return_tiled else attributions\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.HeatmapVisualizer.__call__","title":"<code>__call__(attributions, x, output_file=None, imshow=True, fig=None, return_tiled=False, overlay_opacity=None, normalization_type=None, blur=None, cmap=None)</code>","text":"<p>Visualizes the given attributions by overlaying an attribution heatmap  over the given image.</p> <p>Parameters:</p> Name Type Description Default <code>attributions</code> <p>A <code>np.ndarray</code> containing the attributions to be visualized.</p> required <code>x</code> <p>A <code>np.ndarray</code> of items in the same shape as <code>attributions</code> corresponding to the records explained by the given  attributions. The visualization will be superimposed onto the corresponding set of records.</p> required <code>output_file</code> <p>File name to save the visualization image to. If <code>None</code>, no image will be saved, but the figure can still be displayed.</p> <code>None</code> <code>imshow</code> <p>If true, a the visualization will be displayed. Otherwise the figure will not be displayed, but the figure can still be saved.</p> <code>True</code> <code>fig</code> <p>The <code>pyplot</code> figure to display the visualization in. If <code>None</code>, a new figure will be created.</p> <code>None</code> <code>return_tiled</code> <p>If true, the returned array will be in the same shape as the visualization, with no batch dimension and the samples in the batch tiled along the width and height dimensions. If false, the returned array will be reshaped to match <code>attributions</code>.</p> <code>False</code> <code>overlay_opacity</code> <p>float Value in the range [0, 1] specifying the opacity for the heatmap overlay. If <code>None</code>, defaults to the value supplied to the  constructor.</p> <code>None</code> <code>normalization_type</code> <p>Specifies one of the following configurations for normalizing the attributions (each item is normalized separately):</p> <ul> <li><code>'unsigned_max'</code>: normalizes the attributions to the range    [-1, 1] by dividing the attributions by the maximum absolute    attribution value.</li> <li><code>'unsigned_max_positive_centered'</code>: same as above, but scales   the values to the range [0, 1], with negative scores less than   0.5 and positive scores greater than 0.5. </li> <li><code>'magnitude_max'</code>: takes the absolute value of the    attributions, then normalizes the attributions to the range    [0, 1] by dividing by the maximum absolute attribution value.</li> <li><code>'magnitude_sum'</code>: takes the absolute value of the    attributions, then scales them such that they sum to 1. If    this option is used, each channel is normalized separately,    such that each channel sums to 1.</li> <li><code>'signed_max'</code>: normalizes the attributions to the range    [-1, 1] by dividing the positive values by the maximum    positive attribution value and the negative values by the    minimum negative attribution value.</li> <li><code>'signed_max_positive_centered'</code>: same as above, but scales    the values to the range [0, 1], with negative scores less than   0.5 and positive scores greater than 0.5.</li> <li><code>'signed_sum'</code>: scales the positive attributions such that    they sum to 1 and the negative attributions such that they   scale to -1. If this option is used, each channel is    normalized separately.</li> <li><code>'01'</code>: normalizes the attributions to the range [0, 1] by    subtracting the minimum attribution value then dividing by the   maximum attribution value.</li> <li><code>'unnormalized'</code>: leaves the attributions unaffected.</li> </ul> <p>If <code>None</code>, defaults to the value supplied to the constructor.</p> <code>None</code> <code>blur</code> <p>Gives the radius of a Gaussian blur to be applied to the  attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If <code>None</code>, defaults to the value supplied to the constructor.</p> <code>None</code> <code>cmap</code> <p>matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If <code>None</code>, defaults to the value supplied to the constructor.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>A <code>np.ndarray</code> array of the numerical representation of the</p> <code>np.ndarray</code> <p>attributions as modified for the visualization. This includes </p> <code>np.ndarray</code> <p>normalization, blurring, etc.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>def __call__(\n    self,\n    attributions,\n    x,\n    output_file=None,\n    imshow=True,\n    fig=None,\n    return_tiled=False,\n    overlay_opacity=None,\n    normalization_type=None,\n    blur=None,\n    cmap=None\n) -&gt; np.ndarray:\n\"\"\"\n    Visualizes the given attributions by overlaying an attribution heatmap \n    over the given image.\n\n    Parameters:\n        attributions:\n            A `np.ndarray` containing the attributions to be visualized.\n\n        x:\n            A `np.ndarray` of items in the same shape as `attributions`\n            corresponding to the records explained by the given \n            attributions. The visualization will be superimposed onto the\n            corresponding set of records.\n\n        output_file:\n            File name to save the visualization image to. If `None`, no\n            image will be saved, but the figure can still be displayed.\n\n        imshow:\n            If true, a the visualization will be displayed. Otherwise the\n            figure will not be displayed, but the figure can still be saved.\n\n        fig:\n            The `pyplot` figure to display the visualization in. If `None`,\n            a new figure will be created.\n\n        return_tiled:\n            If true, the returned array will be in the same shape as the\n            visualization, with no batch dimension and the samples in the\n            batch tiled along the width and height dimensions. If false, the\n            returned array will be reshaped to match `attributions`.\n\n        overlay_opacity: float\n            Value in the range [0, 1] specifying the opacity for the heatmap\n            overlay. If `None`, defaults to the value supplied to the \n            constructor.\n\n        normalization_type:\n            Specifies one of the following configurations for normalizing\n            the attributions (each item is normalized separately):\n\n            - `'unsigned_max'`: normalizes the attributions to the range \n              [-1, 1] by dividing the attributions by the maximum absolute \n              attribution value.\n            - `'unsigned_max_positive_centered'`: same as above, but scales\n              the values to the range [0, 1], with negative scores less than\n              0.5 and positive scores greater than 0.5. \n            - `'magnitude_max'`: takes the absolute value of the \n              attributions, then normalizes the attributions to the range \n              [0, 1] by dividing by the maximum absolute attribution value.\n            - `'magnitude_sum'`: takes the absolute value of the \n              attributions, then scales them such that they sum to 1. If \n              this option is used, each channel is normalized separately, \n              such that each channel sums to 1.\n            - `'signed_max'`: normalizes the attributions to the range \n              [-1, 1] by dividing the positive values by the maximum \n              positive attribution value and the negative values by the \n              minimum negative attribution value.\n            - `'signed_max_positive_centered'`: same as above, but scales \n              the values to the range [0, 1], with negative scores less than\n              0.5 and positive scores greater than 0.5.\n            - `'signed_sum'`: scales the positive attributions such that \n              they sum to 1 and the negative attributions such that they\n              scale to -1. If this option is used, each channel is \n              normalized separately.\n            - `'01'`: normalizes the attributions to the range [0, 1] by \n              subtracting the minimum attribution value then dividing by the\n              maximum attribution value.\n            - `'unnormalized'`: leaves the attributions unaffected.\n\n            If `None`, defaults to the value supplied to the constructor.\n\n        blur:\n            Gives the radius of a Gaussian blur to be applied to the \n            attributions before visualizing. This can be used to help focus\n            on salient regions rather than specific salient pixels. If\n            `None`, defaults to the value supplied to the constructor.\n\n        cmap: matplotlib.colors.Colormap | str, optional\n            Colormap or name of a Colormap to use for the visualization. If\n            `None`, defaults to the value supplied to the constructor.\n\n    Returns:\n        A `np.ndarray` array of the numerical representation of the\n        attributions as modified for the visualization. This includes \n        normalization, blurring, etc.\n    \"\"\"\n    _, normalization_type, blur, cmap = self._check_args(\n        attributions, None, normalization_type, blur, cmap\n    )\n\n    # Combine the channels.\n    attributions = attributions.mean(\n        axis=get_backend().channel_axis, keepdims=True\n    )\n\n    # Blur the attributions so the explanation is smoother.\n    if blur:\n        attributions = self._blur(attributions, blur)\n\n    # Normalize the attributions.\n    attributions = self._normalize(attributions, normalization_type)\n\n    tiled_attributions = self.tiler.tile(attributions)\n\n    # Normalize the pixels to be in the range [0, 1].\n    x = self._normalize(x, '01')\n    tiled_x = self.tiler.tile(x)\n\n    if cmap is None:\n        cmap = self.default_cmap\n\n    if overlay_opacity is None:\n        overlay_opacity = self.default_overlay_opacity\n\n    # Display the figure:\n    _fig = plt.figure() if fig is None else fig\n\n    plt.axis('off')\n    plt.imshow(tiled_x)\n    plt.imshow(tiled_attributions, alpha=overlay_opacity, cmap=cmap)\n\n    if output_file:\n        plt.savefig(output_file, bbox_inches=0)\n\n    if imshow:\n        plt.show()\n\n    elif fig is None:\n        plt.close(_fig)\n\n    return tiled_attributions if return_tiled else attributions\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.HeatmapVisualizer.__init__","title":"<code>__init__(overlay_opacity=0.5, normalization_type=None, blur=10.0, cmap='jet')</code>","text":"<p>Configures the default parameters for the <code>__call__</code> method (these can  be overridden by passing in values to <code>__call__</code>).</p> <p>Parameters:</p> Name Type Description Default <code>overlay_opacity</code> <p>float Value in the range [0, 1] specifying the opacity for the heatmap overlay.</p> <code>0.5</code> <code>normalization_type</code> <p>Specifies one of the following configurations for normalizing the attributions (each item is normalized separately):</p> <ul> <li><code>'unsigned_max'</code>: normalizes the attributions to the range    [-1, 1] by dividing the attributions by the maximum absolute    attribution value.</li> <li><code>'unsigned_max_positive_centered'</code>: same as above, but scales   the values to the range [0, 1], with negative scores less than   0.5 and positive scores greater than 0.5. </li> <li><code>'magnitude_max'</code>: takes the absolute value of the    attributions, then normalizes the attributions to the range    [0, 1] by dividing by the maximum absolute attribution value.</li> <li><code>'magnitude_sum'</code>: takes the absolute value of the    attributions, then scales them such that they sum to 1. If    this option is used, each channel is normalized separately,    such that each channel sums to 1.</li> <li><code>'signed_max'</code>: normalizes the attributions to the range    [-1, 1] by dividing the positive values by the maximum    positive attribution value and the negative values by the    minimum negative attribution value.</li> <li><code>'signed_max_positive_centered'</code>: same as above, but scales    the values to the range [0, 1], with negative scores less than   0.5 and positive scores greater than 0.5.</li> <li><code>'signed_sum'</code>: scales the positive attributions such that    they sum to 1 and the negative attributions such that they   scale to -1. If this option is used, each channel is    normalized separately.</li> <li><code>'01'</code>: normalizes the attributions to the range [0, 1] by    subtracting the minimum attribution value then dividing by the   maximum attribution value.</li> <li><code>'unnormalized'</code>: leaves the attributions unaffected.</li> </ul> <p>If <code>None</code>, either <code>'unsigned_max'</code> (for single-channel data) or  <code>'unsigned_max_positive_centered'</code> (for multi-channel data) is used.</p> <code>None</code> <code>blur</code> <p>Gives the radius of a Gaussian blur to be applied to the  attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels.</p> <code>10.0</code> <code>cmap</code> <p>matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If  <code>None</code>, the colormap will be chosen based on the normalization  type. This argument is only used for single-channel data (including when <code>combine_channels</code> is True).</p> <code>'jet'</code> Source code in <code>trulens/visualizations.py</code> <pre><code>def __init__(\n    self,\n    overlay_opacity=0.5,\n    normalization_type=None,\n    blur=10.,\n    cmap='jet'\n):\n\"\"\"\n    Configures the default parameters for the `__call__` method (these can \n    be overridden by passing in values to `__call__`).\n\n    Parameters:\n        overlay_opacity: float\n            Value in the range [0, 1] specifying the opacity for the heatmap\n            overlay.\n\n        normalization_type:\n            Specifies one of the following configurations for normalizing\n            the attributions (each item is normalized separately):\n\n            - `'unsigned_max'`: normalizes the attributions to the range \n              [-1, 1] by dividing the attributions by the maximum absolute \n              attribution value.\n            - `'unsigned_max_positive_centered'`: same as above, but scales\n              the values to the range [0, 1], with negative scores less than\n              0.5 and positive scores greater than 0.5. \n            - `'magnitude_max'`: takes the absolute value of the \n              attributions, then normalizes the attributions to the range \n              [0, 1] by dividing by the maximum absolute attribution value.\n            - `'magnitude_sum'`: takes the absolute value of the \n              attributions, then scales them such that they sum to 1. If \n              this option is used, each channel is normalized separately, \n              such that each channel sums to 1.\n            - `'signed_max'`: normalizes the attributions to the range \n              [-1, 1] by dividing the positive values by the maximum \n              positive attribution value and the negative values by the \n              minimum negative attribution value.\n            - `'signed_max_positive_centered'`: same as above, but scales \n              the values to the range [0, 1], with negative scores less than\n              0.5 and positive scores greater than 0.5.\n            - `'signed_sum'`: scales the positive attributions such that \n              they sum to 1 and the negative attributions such that they\n              scale to -1. If this option is used, each channel is \n              normalized separately.\n            - `'01'`: normalizes the attributions to the range [0, 1] by \n              subtracting the minimum attribution value then dividing by the\n              maximum attribution value.\n            - `'unnormalized'`: leaves the attributions unaffected.\n\n            If `None`, either `'unsigned_max'` (for single-channel data) or \n            `'unsigned_max_positive_centered'` (for multi-channel data) is\n            used.\n\n        blur:\n            Gives the radius of a Gaussian blur to be applied to the \n            attributions before visualizing. This can be used to help focus\n            on salient regions rather than specific salient pixels.\n\n        cmap: matplotlib.colors.Colormap | str, optional\n            Colormap or name of a Colormap to use for the visualization. If \n            `None`, the colormap will be chosen based on the normalization \n            type. This argument is only used for single-channel data\n            (including when `combine_channels` is True).\n    \"\"\"\n\n    super().__init__(\n        combine_channels=True,\n        normalization_type=normalization_type,\n        blur=blur,\n        cmap=cmap\n    )\n\n    self.default_overlay_opacity = overlay_opacity\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.IPython","title":"<code>IPython</code>","text":"<p>         Bases: <code>HTML</code></p> <p>Interactive python visualization output format.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>class IPython(HTML):\n\"\"\"Interactive python visualization output format.\"\"\"\n\n    def __init__(self):\n        super(IPython, self).__init__()\n        try:\n            self.m_ipy = importlib.import_module(\"IPython\")\n        except:\n            raise ImportError(\n                \"Jupyter output requires IPython python module. Try 'pip install ipykernel'.\"\n            )\n\n    def render(self, s: str):\n        html = HTML.render(self, s)\n        return self.m_ipy.display.HTML(html)\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.MaskVisualizer","title":"<code>MaskVisualizer</code>","text":"<p>         Bases: <code>object</code></p> <p>Visualizes attributions by masking the original image to highlight the regions with influence above a given threshold percentile. Intended  particularly for use with input-attributions.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>class MaskVisualizer(object):\n\"\"\"\n    Visualizes attributions by masking the original image to highlight the\n    regions with influence above a given threshold percentile. Intended \n    particularly for use with input-attributions.\n    \"\"\"\n\n    def __init__(\n        self,\n        blur=5.,\n        threshold=0.5,\n        masked_opacity=0.2,\n        combine_channels=True,\n        use_attr_as_opacity=False,\n        positive_only=True\n    ):\n\"\"\"\n        Configures the default parameters for the `__call__` method (these can \n        be overridden by passing in values to `__call__`).\n\n        Parameters:\n            blur:\n                Gives the radius of a Gaussian blur to be applied to the \n                attributions before visualizing. This can be used to help focus\n                on salient regions rather than specific salient pixels.\n\n            threshold:\n                Value in the range [0, 1]. Attribution values at or  below the \n                percentile given by `threshold` (after normalization, blurring,\n                etc.) will be masked.\n\n            masked_opacity: \n                Value in the range [0, 1] specifying the opacity for the parts\n                of the image that are masked.\n\n            combine_channels:\n                If `True`, the attributions will be averaged across the channel\n                dimension, resulting in a 1-channel attribution map.\n\n            use_attr_as_opacity:\n                If `True`, instead of using `threshold` and `masked_opacity`,\n                the opacity of each pixel is given by the 0-1-normalized \n                attribution value.\n\n            positive_only:\n                If `True`, only pixels with positive attribution will be \n                unmasked (or given nonzero opacity when `use_attr_as_opacity` is\n                true).\n        \"\"\"\n\n        self.default_blur = blur\n        self.default_thresh = threshold\n        self.default_masked_opacity = masked_opacity\n        self.default_combine_channels = combine_channels\n\n        # TODO(klas): in the future we can allow configuring of tiling settings\n        #   by allowing the user to specify the tiler.\n        self.tiler = Tiler()\n\n    def __call__(\n        self,\n        attributions,\n        x,\n        output_file=None,\n        imshow=True,\n        fig=None,\n        return_tiled=True,\n        blur=None,\n        threshold=None,\n        masked_opacity=None,\n        combine_channels=None,\n        use_attr_as_opacity=None,\n        positive_only=None\n    ):\n        channel_axis = get_backend().channel_axis\n        if attributions.shape != x.shape:\n            raise ValueError(\n                'Shape of `attributions` {} must match shape of `x` {}'.format(\n                    attributions.shape, x.shape\n                )\n            )\n\n        if blur is None:\n            blur = self.default_blur\n\n        if threshold is None:\n            threshold = self.default_thresh\n\n        if masked_opacity is None:\n            masked_opacity = self.default_masked_opacity\n\n        if combine_channels is None:\n            combine_channels = self.default_combine_channels\n\n        if len(attributions.shape) != 4:\n            raise ValueError(\n                '`MaskVisualizer` is inteded for 4-D image-format data. Given '\n                'input with dimension {}'.format(len(attributions.shape))\n            )\n\n        if combine_channels is None:\n            combine_channels = self.default_combine_channels\n\n        if combine_channels:\n            attributions = attributions.mean(axis=channel_axis, keepdims=True)\n\n        if x.shape[channel_axis] not in (1, 3, 4):\n            raise ValueError(\n                'To visualize, attributions must have either 1, 3, or 4 color '\n                'channels, but Visualizer got {} channels.\\n'\n                'If you are visualizing an internal layer, consider setting '\n                '`combine_channels` to True'.format(\n                    attributions.shape[channel_axis]\n                )\n            )\n\n        # Blur the attributions so the explanation is smoother.\n        if blur is not None:\n            attributions = [gaussian_filter(a, blur) for a in attributions]\n\n        # If `positive_only` clip attributions.\n        if positive_only:\n            attributions = np.maximum(attributions, 0)\n\n        # Normalize the attributions to be in the range [0, 1].\n        attributions = [a - a.min() for a in attributions]\n        attributions = [\n            0. * a if a.max() == 0. else a / a.max() for a in attributions\n        ]\n\n        # Normalize the pixels to be in the range [0, 1]\n        x = [xc - xc.min() for xc in x]\n        x = np.array([0. * xc if xc.max() == 0. else xc / xc.max() for xc in x])\n\n        # Threshold the attributions to create a mask.\n        if threshold is not None:\n            percentiles = [\n                np.percentile(a, 100 * threshold) for a in attributions\n            ]\n            masks = np.array(\n                [\n                    np.maximum(a &gt; p, masked_opacity)\n                    for a, p in zip(attributions, percentiles)\n                ]\n            )\n\n        else:\n            masks = np.array(attributions)\n\n        # Use the mask on the original image to visualize the explanation.\n        attributions = masks * x\n        tiled_attributions = self.tiler.tile(attributions)\n\n        if imshow:\n            plt.axis('off')\n            plt.imshow(tiled_attributions)\n\n            if output_file:\n                plt.savefig(output_file, bbox_inches=0)\n\n        return tiled_attributions if return_tiled else attributions\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.MaskVisualizer.__init__","title":"<code>__init__(blur=5.0, threshold=0.5, masked_opacity=0.2, combine_channels=True, use_attr_as_opacity=False, positive_only=True)</code>","text":"<p>Configures the default parameters for the <code>__call__</code> method (these can  be overridden by passing in values to <code>__call__</code>).</p> <p>Parameters:</p> Name Type Description Default <code>blur</code> <p>Gives the radius of a Gaussian blur to be applied to the  attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels.</p> <code>5.0</code> <code>threshold</code> <p>Value in the range [0, 1]. Attribution values at or  below the  percentile given by <code>threshold</code> (after normalization, blurring, etc.) will be masked.</p> <code>0.5</code> <code>masked_opacity</code> <p>Value in the range [0, 1] specifying the opacity for the parts of the image that are masked.</p> <code>0.2</code> <code>combine_channels</code> <p>If <code>True</code>, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map.</p> <code>True</code> <code>use_attr_as_opacity</code> <p>If <code>True</code>, instead of using <code>threshold</code> and <code>masked_opacity</code>, the opacity of each pixel is given by the 0-1-normalized  attribution value.</p> <code>False</code> <code>positive_only</code> <p>If <code>True</code>, only pixels with positive attribution will be  unmasked (or given nonzero opacity when <code>use_attr_as_opacity</code> is true).</p> <code>True</code> Source code in <code>trulens/visualizations.py</code> <pre><code>def __init__(\n    self,\n    blur=5.,\n    threshold=0.5,\n    masked_opacity=0.2,\n    combine_channels=True,\n    use_attr_as_opacity=False,\n    positive_only=True\n):\n\"\"\"\n    Configures the default parameters for the `__call__` method (these can \n    be overridden by passing in values to `__call__`).\n\n    Parameters:\n        blur:\n            Gives the radius of a Gaussian blur to be applied to the \n            attributions before visualizing. This can be used to help focus\n            on salient regions rather than specific salient pixels.\n\n        threshold:\n            Value in the range [0, 1]. Attribution values at or  below the \n            percentile given by `threshold` (after normalization, blurring,\n            etc.) will be masked.\n\n        masked_opacity: \n            Value in the range [0, 1] specifying the opacity for the parts\n            of the image that are masked.\n\n        combine_channels:\n            If `True`, the attributions will be averaged across the channel\n            dimension, resulting in a 1-channel attribution map.\n\n        use_attr_as_opacity:\n            If `True`, instead of using `threshold` and `masked_opacity`,\n            the opacity of each pixel is given by the 0-1-normalized \n            attribution value.\n\n        positive_only:\n            If `True`, only pixels with positive attribution will be \n            unmasked (or given nonzero opacity when `use_attr_as_opacity` is\n            true).\n    \"\"\"\n\n    self.default_blur = blur\n    self.default_thresh = threshold\n    self.default_masked_opacity = masked_opacity\n    self.default_combine_channels = combine_channels\n\n    # TODO(klas): in the future we can allow configuring of tiling settings\n    #   by allowing the user to specify the tiler.\n    self.tiler = Tiler()\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.NLP","title":"<code>NLP</code>","text":"<p>         Bases: <code>object</code></p> <p>NLP Visualization tools.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>class NLP(object):\n\"\"\"NLP Visualization tools.\"\"\"\n\n    # Batches of text inputs not yet tokenized.\n    TextBatch = TypeVar(\"TextBatch\")\n\n    # Inputs that are directly accepted by wrapped models, tokenized.\n    # TODO(piotrm): Reuse other typevars/aliases from elsewhere.\n    ModelInput = TypeVar(\"ModelInput\")\n\n    # Outputs produced by wrapped models.\n    # TODO(piotrm): Reuse other typevars/aliases from elsewhere.\n    ModelOutput = TypeVar(\"ModelOutput\")\n\n    def __init__(\n        self,\n        wrapper: ModelWrapper,\n        output: Optional[Output] = None,\n        labels: Optional[Iterable[str]] = None,\n        tokenize: Optional[Callable[[TextBatch], ModelInputs]] = None,\n        decode: Optional[Callable[[Tensor], str]] = None,\n        input_accessor: Optional[Callable[[ModelInputs],\n                                          Iterable[Tensor]]] = None,\n        output_accessor: Optional[Callable[[ModelOutput],\n                                           Iterable[Tensor]]] = None,\n        attr_aggregate: Optional[Callable[[Tensor], Tensor]] = None,\n        hidden_tokens: Optional[Set[int]] = set()\n    ):\n\"\"\"Initializate NLP visualization tools for a given environment.\n\n        Parameters:\n            wrapper: ModelWrapper\n                The wrapped model whose channel we're visualizing.\n\n            output: Output, optional\n                Visualization output format. Defaults to PlainText unless\n                ipython is detected and in which case defaults to IPython\n                format.\n\n            labels: Iterable[str], optional\n                Names of prediction classes for classification models.\n\n            tokenize: Callable[[TextBatch], ModelInput], optional\n                Method to tokenize an instance.\n\n            decode: Callable[[Tensor], str], optional\n                Method to invert/decode the tokenization.\n\n            input_accessor: Callable[[ModelInputs], Iterable[Tensor]], optional\n                Method to extract input/token ids from model inputs (tokenize\n                output) if needed.\n\n            output_accessor: Callable[[ModelOutput], Iterable[Tensor]], optional\n                Method to extract outout logits from output structures if\n                needed.\n\n            attr_aggregate: Callable[[Tensor], Tensor], optional\n                Method to aggregate attribution for embedding into a single\n                value. Defaults to sum.\n\n            hidden_tokens: Set[int], optional\n                For token-based visualizations, which tokens to hide.\n        \"\"\"\n        if output is None:\n            try:\n                # check if running in interactive python (jupyer, colab, etc) to\n                # use appropriate output format\n                get_ipython()\n                output = IPython()\n\n            except NameError:\n                output = PlainText()\n                tru_logger(\n                    \"WARNING: could not guess preferred visualization output format, using PlainText\"\n                )\n\n        # TODO: automatic inference of various parameters for common repositories like huggingface, tfhub.\n\n        self.output = output\n        self.labels = labels\n        self.tokenize = tokenize\n        self.decode = decode\n        self.wrapper = wrapper\n\n        self.input_accessor = input_accessor  # could be inferred\n        self.output_accessor = output_accessor  # could be inferred\n\n        B = get_backend()\n\n        if attr_aggregate is None:\n            attr_aggregate = B.sum\n\n        self.attr_aggregate = attr_aggregate\n\n        self.hidden_tokens = hidden_tokens\n\n    def token_attribution(self, texts: Iterable[str], attr: AttributionMethod):\n\"\"\"Visualize a token-based input attribution on given `texts` inputs via the attribution method `attr`.\n\n        Parameters:\n            texts: Iterable[str]\n                The input texts to visualize.\n\n            attr: AttributionMethod\n                The attribution method to generate the token importances with.\n\n        Returns: Any\n            The visualization in the format specified by this class's `output` parameter.\n        \"\"\"\n\n        B = get_backend()\n\n        if self.tokenize is None:\n            return ValueError(\"tokenize not provided to NLP visualizer.\")\n\n        inputs = self.tokenize(texts)\n\n        outputs = inputs.call_on(self.wrapper._model)\n        attrs = inputs.call_on(attr.attributions)\n\n        content = self.output.blank()\n\n        input_ids = inputs\n        if self.input_accessor is not None:\n            input_ids = self.input_accessor(inputs)\n\n        if (not isinstance(input_ids, Iterable)) or isinstance(input_ids, dict):\n            raise ValueError(\n                f\"Inputs ({input_ids.__class__.__name__}) need to be iterable over instances. You might need to set input_accessor.\"\n            )\n\n        output_logits = outputs\n        if self.output_accessor is not None:\n            output_logits = self.output_accessor(outputs)\n\n        if (not isinstance(output_logits, Iterable)) or isinstance(\n                output_logits, dict):\n            raise ValueError(\n                f\"Outputs ({output_logits.__class__.__name__}) need to be iterable over instances. You might need to set output_accessor.\"\n            )\n\n        for i, (sentence_word_id, attr,\n                logits) in enumerate(zip(input_ids, attrs, output_logits)):\n\n            logits = logits.to('cpu').detach().numpy()\n            pred = logits.argmax()\n\n            if self.labels is not None:\n                pred_name = self.labels[pred]\n            else:\n                pred_name = str(pred)\n\n            sent = self.output.append(\n                self.output.escape(pred_name), \":\", self.output.space()\n            )\n\n            for word_id, attr in zip(sentence_word_id, attr):\n                word_id = int(B.as_array(word_id))\n\n                if word_id in self.hidden_tokens:\n                    continue\n\n                if self.decode is not None:\n                    word = self.decode(word_id)\n                else:\n                    word = str(word_id)\n\n                mag = self.attr_aggregate(attr)\n\n                if word[0] == ' ':\n                    word = word[1:]\n                    sent = self.output.append(sent, self.output.space())\n\n                sent = self.output.append(\n                    sent,\n                    self.output.magnitude_colored(\n                        self.output.escape(word), mag\n                    )\n                )\n\n            content = self.output.append(\n                content, self.output.line(sent), self.output.linebreak(),\n                self.output.linebreak()\n            )\n\n        return self.output.render(content)\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.NLP.__init__","title":"<code>__init__(wrapper, output=None, labels=None, tokenize=None, decode=None, input_accessor=None, output_accessor=None, attr_aggregate=None, hidden_tokens=set())</code>","text":"<p>Initializate NLP visualization tools for a given environment.</p> <p>Parameters:</p> Name Type Description Default <code>wrapper</code> <code>ModelWrapper</code> <p>ModelWrapper The wrapped model whose channel we're visualizing.</p> required <code>output</code> <code>Optional[Output]</code> <p>Output, optional Visualization output format. Defaults to PlainText unless ipython is detected and in which case defaults to IPython format.</p> <code>None</code> <code>labels</code> <code>Optional[Iterable[str]]</code> <p>Iterable[str], optional Names of prediction classes for classification models.</p> <code>None</code> <code>tokenize</code> <code>Optional[Callable[[TextBatch], ModelInputs]]</code> <p>Callable[[TextBatch], ModelInput], optional Method to tokenize an instance.</p> <code>None</code> <code>decode</code> <code>Optional[Callable[[Tensor], str]]</code> <p>Callable[[Tensor], str], optional Method to invert/decode the tokenization.</p> <code>None</code> <code>input_accessor</code> <code>Optional[Callable[[ModelInputs], Iterable[Tensor]]]</code> <p>Callable[[ModelInputs], Iterable[Tensor]], optional Method to extract input/token ids from model inputs (tokenize output) if needed.</p> <code>None</code> <code>output_accessor</code> <code>Optional[Callable[[ModelOutput], Iterable[Tensor]]]</code> <p>Callable[[ModelOutput], Iterable[Tensor]], optional Method to extract outout logits from output structures if needed.</p> <code>None</code> <code>attr_aggregate</code> <code>Optional[Callable[[Tensor], Tensor]]</code> <p>Callable[[Tensor], Tensor], optional Method to aggregate attribution for embedding into a single value. Defaults to sum.</p> <code>None</code> <code>hidden_tokens</code> <code>Optional[Set[int]]</code> <p>Set[int], optional For token-based visualizations, which tokens to hide.</p> <code>set()</code> Source code in <code>trulens/visualizations.py</code> <pre><code>def __init__(\n    self,\n    wrapper: ModelWrapper,\n    output: Optional[Output] = None,\n    labels: Optional[Iterable[str]] = None,\n    tokenize: Optional[Callable[[TextBatch], ModelInputs]] = None,\n    decode: Optional[Callable[[Tensor], str]] = None,\n    input_accessor: Optional[Callable[[ModelInputs],\n                                      Iterable[Tensor]]] = None,\n    output_accessor: Optional[Callable[[ModelOutput],\n                                       Iterable[Tensor]]] = None,\n    attr_aggregate: Optional[Callable[[Tensor], Tensor]] = None,\n    hidden_tokens: Optional[Set[int]] = set()\n):\n\"\"\"Initializate NLP visualization tools for a given environment.\n\n    Parameters:\n        wrapper: ModelWrapper\n            The wrapped model whose channel we're visualizing.\n\n        output: Output, optional\n            Visualization output format. Defaults to PlainText unless\n            ipython is detected and in which case defaults to IPython\n            format.\n\n        labels: Iterable[str], optional\n            Names of prediction classes for classification models.\n\n        tokenize: Callable[[TextBatch], ModelInput], optional\n            Method to tokenize an instance.\n\n        decode: Callable[[Tensor], str], optional\n            Method to invert/decode the tokenization.\n\n        input_accessor: Callable[[ModelInputs], Iterable[Tensor]], optional\n            Method to extract input/token ids from model inputs (tokenize\n            output) if needed.\n\n        output_accessor: Callable[[ModelOutput], Iterable[Tensor]], optional\n            Method to extract outout logits from output structures if\n            needed.\n\n        attr_aggregate: Callable[[Tensor], Tensor], optional\n            Method to aggregate attribution for embedding into a single\n            value. Defaults to sum.\n\n        hidden_tokens: Set[int], optional\n            For token-based visualizations, which tokens to hide.\n    \"\"\"\n    if output is None:\n        try:\n            # check if running in interactive python (jupyer, colab, etc) to\n            # use appropriate output format\n            get_ipython()\n            output = IPython()\n\n        except NameError:\n            output = PlainText()\n            tru_logger(\n                \"WARNING: could not guess preferred visualization output format, using PlainText\"\n            )\n\n    # TODO: automatic inference of various parameters for common repositories like huggingface, tfhub.\n\n    self.output = output\n    self.labels = labels\n    self.tokenize = tokenize\n    self.decode = decode\n    self.wrapper = wrapper\n\n    self.input_accessor = input_accessor  # could be inferred\n    self.output_accessor = output_accessor  # could be inferred\n\n    B = get_backend()\n\n    if attr_aggregate is None:\n        attr_aggregate = B.sum\n\n    self.attr_aggregate = attr_aggregate\n\n    self.hidden_tokens = hidden_tokens\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.NLP.token_attribution","title":"<code>token_attribution(texts, attr)</code>","text":"<p>Visualize a token-based input attribution on given <code>texts</code> inputs via the attribution method <code>attr</code>.</p> <p>Parameters:</p> Name Type Description Default <code>texts</code> <code>Iterable[str]</code> <p>Iterable[str] The input texts to visualize.</p> required <code>attr</code> <code>AttributionMethod</code> <p>AttributionMethod The attribution method to generate the token importances with.</p> required <p>Any</p> Type Description <p>The visualization in the format specified by this class's <code>output</code> parameter.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>def token_attribution(self, texts: Iterable[str], attr: AttributionMethod):\n\"\"\"Visualize a token-based input attribution on given `texts` inputs via the attribution method `attr`.\n\n    Parameters:\n        texts: Iterable[str]\n            The input texts to visualize.\n\n        attr: AttributionMethod\n            The attribution method to generate the token importances with.\n\n    Returns: Any\n        The visualization in the format specified by this class's `output` parameter.\n    \"\"\"\n\n    B = get_backend()\n\n    if self.tokenize is None:\n        return ValueError(\"tokenize not provided to NLP visualizer.\")\n\n    inputs = self.tokenize(texts)\n\n    outputs = inputs.call_on(self.wrapper._model)\n    attrs = inputs.call_on(attr.attributions)\n\n    content = self.output.blank()\n\n    input_ids = inputs\n    if self.input_accessor is not None:\n        input_ids = self.input_accessor(inputs)\n\n    if (not isinstance(input_ids, Iterable)) or isinstance(input_ids, dict):\n        raise ValueError(\n            f\"Inputs ({input_ids.__class__.__name__}) need to be iterable over instances. You might need to set input_accessor.\"\n        )\n\n    output_logits = outputs\n    if self.output_accessor is not None:\n        output_logits = self.output_accessor(outputs)\n\n    if (not isinstance(output_logits, Iterable)) or isinstance(\n            output_logits, dict):\n        raise ValueError(\n            f\"Outputs ({output_logits.__class__.__name__}) need to be iterable over instances. You might need to set output_accessor.\"\n        )\n\n    for i, (sentence_word_id, attr,\n            logits) in enumerate(zip(input_ids, attrs, output_logits)):\n\n        logits = logits.to('cpu').detach().numpy()\n        pred = logits.argmax()\n\n        if self.labels is not None:\n            pred_name = self.labels[pred]\n        else:\n            pred_name = str(pred)\n\n        sent = self.output.append(\n            self.output.escape(pred_name), \":\", self.output.space()\n        )\n\n        for word_id, attr in zip(sentence_word_id, attr):\n            word_id = int(B.as_array(word_id))\n\n            if word_id in self.hidden_tokens:\n                continue\n\n            if self.decode is not None:\n                word = self.decode(word_id)\n            else:\n                word = str(word_id)\n\n            mag = self.attr_aggregate(attr)\n\n            if word[0] == ' ':\n                word = word[1:]\n                sent = self.output.append(sent, self.output.space())\n\n            sent = self.output.append(\n                sent,\n                self.output.magnitude_colored(\n                    self.output.escape(word), mag\n                )\n            )\n\n        content = self.output.append(\n            content, self.output.line(sent), self.output.linebreak(),\n            self.output.linebreak()\n        )\n\n    return self.output.render(content)\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.Output","title":"<code>Output</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base class for visualization output formats.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>class Output(ABC):\n\"\"\"Base class for visualization output formats.\"\"\"\n\n    @abstractmethod\n    def blank(self) -&gt; str:\n        ...\n\n    @abstractmethod\n    def space(self) -&gt; str:\n        ...\n\n    @abstractmethod\n    def escape(self, s: str) -&gt; str:\n        ...\n\n    @abstractmethod\n    def line(self, s: str) -&gt; str:\n        ...\n\n    @abstractmethod\n    def magnitude_colored(self, s: str, mag: float) -&gt; str:\n        ...\n\n    @abstractmethod\n    def append(self, *parts: Iterable[str]) -&gt; str:\n        ...\n\n    @abstractmethod\n    def render(self, s: str) -&gt; str:\n        ...\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.PlainText","title":"<code>PlainText</code>","text":"<p>         Bases: <code>Output</code></p> <p>Plain text visualization output format.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>class PlainText(Output):\n\"\"\"Plain text visualization output format.\"\"\"\n\n    def blank(self):\n        return \"\"\n\n    def space(self):\n        return \" \"\n\n    def escape(self, s):\n        return s\n\n    def line(self, s):\n        return s\n\n    def magnitude_colored(self, s, mag):\n        return f\"{s}({mag:0.3f})\"\n\n    def append(self, *parts):\n        return ''.join(parts)\n\n    def render(self, s):\n        return s\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.Tiler","title":"<code>Tiler</code>","text":"<p>         Bases: <code>object</code></p> <p>Used to tile batched images or attributions.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>class Tiler(object):\n\"\"\"\n    Used to tile batched images or attributions.\n    \"\"\"\n\n    def tile(self, a: np.ndarray) -&gt; np.ndarray:\n\"\"\"\n        Tiles the given array into a grid that is as square as possible.\n\n        Parameters:\n            a:\n                An array of 4D batched image data.\n\n        Returns:\n            A tiled array of the images from `a`. The resulting array has rank\n            3 for color images, and 2 for grayscale images (the batch dimension\n            is removed, as well as the channel dimension for grayscale images).\n            The resulting array has its color channel dimension ordered last to\n            fit the requirements of the `matplotlib` library.\n        \"\"\"\n\n        # `pyplot` expects the channels to come last.\n        if get_backend().dim_order == 'channels_first':\n            a = a.transpose((0, 2, 3, 1))\n\n        n, h, w, c = a.shape\n\n        rows = int(np.sqrt(n))\n        cols = int(np.ceil(float(n) / rows))\n\n        new_a = np.zeros((h * rows, w * cols, c))\n\n        for i, x in enumerate(a):\n            row = i // cols\n            col = i % cols\n            new_a[row * h:(row + 1) * h, col * w:(col + 1) * w] = x\n\n        return np.squeeze(new_a)\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.Tiler.tile","title":"<code>tile(a)</code>","text":"<p>Tiles the given array into a grid that is as square as possible.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>np.ndarray</code> <p>An array of 4D batched image data.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>A tiled array of the images from <code>a</code>. The resulting array has rank</p> <code>np.ndarray</code> <p>3 for color images, and 2 for grayscale images (the batch dimension</p> <code>np.ndarray</code> <p>is removed, as well as the channel dimension for grayscale images).</p> <code>np.ndarray</code> <p>The resulting array has its color channel dimension ordered last to</p> <code>np.ndarray</code> <p>fit the requirements of the <code>matplotlib</code> library.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>def tile(self, a: np.ndarray) -&gt; np.ndarray:\n\"\"\"\n    Tiles the given array into a grid that is as square as possible.\n\n    Parameters:\n        a:\n            An array of 4D batched image data.\n\n    Returns:\n        A tiled array of the images from `a`. The resulting array has rank\n        3 for color images, and 2 for grayscale images (the batch dimension\n        is removed, as well as the channel dimension for grayscale images).\n        The resulting array has its color channel dimension ordered last to\n        fit the requirements of the `matplotlib` library.\n    \"\"\"\n\n    # `pyplot` expects the channels to come last.\n    if get_backend().dim_order == 'channels_first':\n        a = a.transpose((0, 2, 3, 1))\n\n    n, h, w, c = a.shape\n\n    rows = int(np.sqrt(n))\n    cols = int(np.ceil(float(n) / rows))\n\n    new_a = np.zeros((h * rows, w * cols, c))\n\n    for i, x in enumerate(a):\n        row = i // cols\n        col = i % cols\n        new_a[row * h:(row + 1) * h, col * w:(col + 1) * w] = x\n\n    return np.squeeze(new_a)\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.Visualizer","title":"<code>Visualizer</code>","text":"<p>         Bases: <code>object</code></p> <p>Visualizes attributions directly as a color image. Intended particularly for use with input-attributions.</p> <p>This can also be used for viewing images (rather than attributions).</p> Source code in <code>trulens/visualizations.py</code> <pre><code>class Visualizer(object):\n\"\"\"\n    Visualizes attributions directly as a color image. Intended particularly for\n    use with input-attributions.\n\n    This can also be used for viewing images (rather than attributions).\n    \"\"\"\n\n    def __init__(\n        self,\n        combine_channels: bool = False,\n        normalization_type: str = None,\n        blur: float = 0.,\n        cmap: Colormap = None\n    ):\n\"\"\"\n        Configures the default parameters for the `__call__` method (these can \n        be overridden by passing in values to `__call__`).\n\n        Parameters:\n            combine_channels:\n                If `True`, the attributions will be averaged across the channel\n                dimension, resulting in a 1-channel attribution map.\n\n            normalization_type:\n                Specifies one of the following configurations for normalizing\n                the attributions (each item is normalized separately):\n\n                - `'unsigned_max'`: normalizes the attributions to the range \n                  [-1, 1] by dividing the attributions by the maximum absolute \n                  attribution value.\n                - `'unsigned_max_positive_centered'`: same as above, but scales\n                  the values to the range [0, 1], with negative scores less than\n                  0.5 and positive scores greater than 0.5. \n                - `'magnitude_max'`: takes the absolute value of the \n                  attributions, then normalizes the attributions to the range \n                  [0, 1] by dividing by the maximum absolute attribution value.\n                - `'magnitude_sum'`: takes the absolute value of the \n                  attributions, then scales them such that they sum to 1. If \n                  this option is used, each channel is normalized separately, \n                  such that each channel sums to 1.\n                - `'signed_max'`: normalizes the attributions to the range \n                  [-1, 1] by dividing the positive values by the maximum \n                  positive attribution value and the negative values by the \n                  minimum negative attribution value.\n                - `'signed_max_positive_centered'`: same as above, but scales \n                  the values to the range [0, 1], with negative scores less than\n                  0.5 and positive scores greater than 0.5.\n                - `'signed_sum'`: scales the positive attributions such that \n                  they sum to 1 and the negative attributions such that they\n                  scale to -1. If this option is used, each channel is \n                  normalized separately.\n                - `'01'`: normalizes the attributions to the range [0, 1] by \n                  subtracting the minimum attribution value then dividing by the\n                  maximum attribution value.\n                - `'unnormalized'`: leaves the attributions unaffected.\n\n                If `None`, either `'unsigned_max'` (for single-channel data) or \n                `'unsigned_max_positive_centered'` (for multi-channel data) is\n                used.\n\n            blur:\n                Gives the radius of a Gaussian blur to be applied to the \n                attributions before visualizing. This can be used to help focus\n                on salient regions rather than specific salient pixels.\n\n            cmap: matplotlib.colors.Colormap | str, optional\n                Colormap or name of a Colormap to use for the visualization. If \n                `None`, the colormap will be chosen based on the normalization \n                type. This argument is only used for single-channel data\n                (including when `combine_channels` is True).\n        \"\"\"\n        self.default_combine_channels = combine_channels\n        self.default_normalization_type = normalization_type\n        self.default_blur = blur\n        self.default_cmap = cmap if cmap is not None else self._get_hotcold()\n\n        # TODO(klas): in the future we can allow configuring of tiling settings\n        #   by allowing the user to specify the tiler.\n        self.tiler = Tiler()\n\n    def __call__(\n        self,\n        attributions,\n        output_file=None,\n        imshow=True,\n        fig=None,\n        return_tiled=False,\n        combine_channels=None,\n        normalization_type=None,\n        blur=None,\n        cmap=None\n    ) -&gt; np.ndarray:\n\"\"\"\n        Visualizes the given attributions.\n\n        Parameters:\n            attributions:\n                A `np.ndarray` containing the attributions to be visualized.\n\n            output_file:\n                File name to save the visualization image to. If `None`, no\n                image will be saved, but the figure can still be displayed.\n\n            imshow:\n                If true, a the visualization will be displayed. Otherwise the\n                figure will not be displayed, but the figure can still be saved.\n\n            fig:\n                The `pyplot` figure to display the visualization in. If `None`,\n                a new figure will be created.\n\n            return_tiled:\n                If true, the returned array will be in the same shape as the\n                visualization, with no batch dimension and the samples in the\n                batch tiled along the width and height dimensions. If false, the\n                returned array will be reshaped to match `attributions`.\n\n            combine_channels:\n                If `True`, the attributions will be averaged across the channel\n                dimension, resulting in a 1-channel attribution map. If `None`,\n                defaults to the value supplied to the constructor.\n\n            normalization_type:\n                Specifies one of the following configurations for normalizing\n                the attributions (each item is normalized separately):\n\n                - `'unsigned_max'`: normalizes the attributions to the range \n                  [-1, 1] by dividing the attributions by the maximum absolute \n                  attribution value.\n                - `'unsigned_max_positive_centered'`: same as above, but scales\n                  the values to the range [0, 1], with negative scores less than\n                  0.5 and positive scores greater than 0.5. \n                - `'magnitude_max'`: takes the absolute value of the \n                  attributions, then normalizes the attributions to the range \n                  [0, 1] by dividing by the maximum absolute attribution value.\n                - `'magnitude_sum'`: takes the absolute value of the \n                  attributions, then scales them such that they sum to 1. If \n                  this option is used, each channel is normalized separately, \n                  such that each channel sums to 1.\n                - `'signed_max'`: normalizes the attributions to the range \n                  [-1, 1] by dividing the positive values by the maximum \n                  positive attribution value and the negative values by the \n                  minimum negative attribution value.\n                - `'signed_max_positive_centered'`: same as above, but scales \n                  the values to the range [0, 1], with negative scores less than\n                  0.5 and positive scores greater than 0.5.\n                - `'signed_sum'`: scales the positive attributions such that \n                  they sum to 1 and the negative attributions such that they\n                  scale to -1. If this option is used, each channel is \n                  normalized separately.\n                - `'01'`: normalizes the attributions to the range [0, 1] by \n                  subtracting the minimum attribution value then dividing by the\n                  maximum attribution value.\n                - `'unnormalized'`: leaves the attributions unaffected.\n\n                If `None`, defaults to the value supplied to the constructor.\n\n            blur:\n                Gives the radius of a Gaussian blur to be applied to the \n                attributions before visualizing. This can be used to help focus\n                on salient regions rather than specific salient pixels. If\n                `None`, defaults to the value supplied to the constructor.\n\n            cmap: matplotlib.colors.Colormap | str, optional\n                Colormap or name of a Colormap to use for the visualization. If\n                `None`, defaults to the value supplied to the constructor.\n\n        Returns:\n            A `np.ndarray` array of the numerical representation of the\n            attributions as modified for the visualization. This includes \n            normalization, blurring, etc.\n        \"\"\"\n        combine_channels, normalization_type, blur, cmap = self._check_args(\n            attributions, combine_channels, normalization_type, blur, cmap\n        )\n\n        # Combine the channels if specified.\n        if combine_channels:\n            attributions = attributions.mean(\n                axis=get_backend().channel_axis, keepdims=True\n            )\n\n        # Blur the attributions so the explanation is smoother.\n        if blur:\n            attributions = self._blur(attributions, blur)\n\n        # Normalize the attributions.\n        attributions = self._normalize(attributions, normalization_type)\n\n        tiled_attributions = self.tiler.tile(attributions)\n\n        # Display the figure:\n        _fig = plt.figure() if fig is None else fig\n\n        plt.axis('off')\n        plt.imshow(tiled_attributions, cmap=cmap)\n\n        if output_file:\n            plt.savefig(output_file, bbox_inches=0)\n\n        if imshow:\n            plt.show()\n\n        elif fig is None:\n            plt.close(_fig)\n\n        return tiled_attributions if return_tiled else attributions\n\n    def _check_args(\n        self, attributions, combine_channels, normalization_type, blur, cmap\n    ):\n\"\"\"\n        Validates the arguments, and sets them to their default values if they\n        are not specified.\n        \"\"\"\n        if attributions.ndim != 4:\n            raise ValueError(\n                '`Visualizer` is inteded for 4-D image-format data. Given '\n                'input with dimension {}'.format(attributions.ndim)\n            )\n\n        if combine_channels is None:\n            combine_channels = self.default_combine_channels\n\n        channel_axis = get_backend().channel_axis\n        if not (attributions.shape[channel_axis] in (1, 3, 4) or\n                combine_channels):\n\n            raise ValueError(\n                'To visualize, attributions must have either 1, 3, or 4 color '\n                'channels, but `Visualizer` got {} channels.\\n'\n                'If you are visualizing an internal layer, consider setting '\n                '`combine_channels` to True'.format(\n                    attributions.shape[channel_axis]\n                )\n            )\n\n        if normalization_type is None:\n            normalization_type = self.default_normalization_type\n\n            if normalization_type is None:\n                if combine_channels or attributions.shape[channel_axis] == 1:\n                    normalization_type = 'unsigned_max'\n\n                else:\n                    normalization_type = 'unsigned_max_positive_centered'\n\n        valid_normalization_types = [\n            'unsigned_max',\n            'unsigned_max_positive_centered',\n            'magnitude_max',\n            'magnitude_sum',\n            'signed_max',\n            'signed_max_positive_centered',\n            'signed_sum',\n            '01',\n            'unnormalized',\n        ]\n        if normalization_type not in valid_normalization_types:\n            raise ValueError(\n                '`norm` must be None or one of the following options:' +\n                ','.join(\n                    [\n                        '\\'{}\\''.form(norm_type)\n                        for norm_type in valid_normalization_types\n                    ]\n                )\n            )\n\n        if blur is None:\n            blur = self.default_blur\n\n        if cmap is None:\n            cmap = self.default_cmap\n\n        return combine_channels, normalization_type, blur, cmap\n\n    def _normalize(self, attributions, normalization_type, eps=1e-20):\n        channel_axis = get_backend().channel_axis\n        if normalization_type == 'unnormalized':\n            return attributions\n\n        split_by_channel = normalization_type.endswith('sum')\n\n        channel_split = [attributions] if split_by_channel else np.split(\n            attributions, attributions.shape[channel_axis], axis=channel_axis\n        )\n\n        normalized_attributions = []\n        for c_map in channel_split:\n            if normalization_type == 'magnitude_max':\n                c_map = np.abs(c_map) / (\n                    np.abs(c_map).max(axis=(1, 2, 3), keepdims=True) + eps\n                )\n\n            elif normalization_type == 'magnitude_sum':\n                c_map = np.abs(c_map) / (\n                    np.abs(c_map).sum(axis=(1, 2, 3), keepdims=True) + eps\n                )\n\n            elif normalization_type.startswith('signed_max'):\n                postive_max = c_map.max(axis=(1, 2, 3), keepdims=True)\n                negative_max = (-c_map).max(axis=(1, 2, 3), keepdims=True)\n\n                # Normalize the postive socres to [0, 1] and negative socresn to\n                # [-1, 0].\n                normalization_factor = np.where(\n                    c_map &gt;= 0, postive_max, negative_max\n                )\n                c_map = c_map / (normalization_factor + eps)\n\n                # If positive-centered, normalize so that all scores are in the\n                # range [0, 1], with negative scores less than 0.5 and positive\n                # scores greater than 0.5.\n                if normalization_type.endswith('positive_centered'):\n                    c_map = c_map / 2. + 0.5\n\n            elif normalization_type == 'signed_sum':\n                postive_max = np.maximum(c_map, 0).sum(\n                    axis=(1, 2, 3), keepdims=True\n                )\n                negative_max = np.maximum(-c_map, 0).sum(\n                    axis=(1, 2, 3), keepdims=True\n                )\n\n                # Normalize the postive socres to ensure they sum to 1 and the\n                # negative scores to ensure they sum to -1.\n                normalization_factor = np.where(\n                    c_map &gt;= 0, postive_max, negative_max\n                )\n                c_map = c_map / (normalization_factor + eps)\n\n            elif normalization_type.startswith('unsigned_max'):\n                c_map = c_map / (\n                    np.abs(c_map).max(axis=(1, 2, 3), keepdims=True) + eps\n                )\n\n                # If positive-centered, normalize so that all scores are in the\n                # range [0, 1], with negative scores less than 0.5 and positive\n                # scores greater than 0.5.\n                if normalization_type.endswith('positive_centered'):\n                    c_map = c_map / 2. + 0.5\n\n            elif normalization_type == '01':\n                c_map = c_map - c_map.min(axis=(1, 2, 3), keepdims=True)\n                c_map = c_map / (c_map.max(axis=(1, 2, 3), keepdims=True) + eps)\n\n            normalized_attributions.append(c_map)\n\n        return np.concatenate(normalized_attributions, axis=channel_axis)\n\n    def _blur(self, attributions, blur):\n        for i in range(attributions.shape[0]):\n            attributions[i] = gaussian_filter(attributions[i], blur)\n\n        return attributions\n\n    def _get_hotcold(self):\n        hot = cm.get_cmap('hot', 128)\n        cool = cm.get_cmap('cool', 128)\n        binary = cm.get_cmap('binary', 128)\n        hotcold = np.vstack(\n            (\n                binary(np.linspace(0, 1, 128)) * cool(np.linspace(0, 1, 128)),\n                hot(np.linspace(0, 1, 128))\n            )\n        )\n\n        return ListedColormap(hotcold, name='hotcold')\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.Visualizer.__call__","title":"<code>__call__(attributions, output_file=None, imshow=True, fig=None, return_tiled=False, combine_channels=None, normalization_type=None, blur=None, cmap=None)</code>","text":"<p>Visualizes the given attributions.</p> <p>Parameters:</p> Name Type Description Default <code>attributions</code> <p>A <code>np.ndarray</code> containing the attributions to be visualized.</p> required <code>output_file</code> <p>File name to save the visualization image to. If <code>None</code>, no image will be saved, but the figure can still be displayed.</p> <code>None</code> <code>imshow</code> <p>If true, a the visualization will be displayed. Otherwise the figure will not be displayed, but the figure can still be saved.</p> <code>True</code> <code>fig</code> <p>The <code>pyplot</code> figure to display the visualization in. If <code>None</code>, a new figure will be created.</p> <code>None</code> <code>return_tiled</code> <p>If true, the returned array will be in the same shape as the visualization, with no batch dimension and the samples in the batch tiled along the width and height dimensions. If false, the returned array will be reshaped to match <code>attributions</code>.</p> <code>False</code> <code>combine_channels</code> <p>If <code>True</code>, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If <code>None</code>, defaults to the value supplied to the constructor.</p> <code>None</code> <code>normalization_type</code> <p>Specifies one of the following configurations for normalizing the attributions (each item is normalized separately):</p> <ul> <li><code>'unsigned_max'</code>: normalizes the attributions to the range    [-1, 1] by dividing the attributions by the maximum absolute    attribution value.</li> <li><code>'unsigned_max_positive_centered'</code>: same as above, but scales   the values to the range [0, 1], with negative scores less than   0.5 and positive scores greater than 0.5. </li> <li><code>'magnitude_max'</code>: takes the absolute value of the    attributions, then normalizes the attributions to the range    [0, 1] by dividing by the maximum absolute attribution value.</li> <li><code>'magnitude_sum'</code>: takes the absolute value of the    attributions, then scales them such that they sum to 1. If    this option is used, each channel is normalized separately,    such that each channel sums to 1.</li> <li><code>'signed_max'</code>: normalizes the attributions to the range    [-1, 1] by dividing the positive values by the maximum    positive attribution value and the negative values by the    minimum negative attribution value.</li> <li><code>'signed_max_positive_centered'</code>: same as above, but scales    the values to the range [0, 1], with negative scores less than   0.5 and positive scores greater than 0.5.</li> <li><code>'signed_sum'</code>: scales the positive attributions such that    they sum to 1 and the negative attributions such that they   scale to -1. If this option is used, each channel is    normalized separately.</li> <li><code>'01'</code>: normalizes the attributions to the range [0, 1] by    subtracting the minimum attribution value then dividing by the   maximum attribution value.</li> <li><code>'unnormalized'</code>: leaves the attributions unaffected.</li> </ul> <p>If <code>None</code>, defaults to the value supplied to the constructor.</p> <code>None</code> <code>blur</code> <p>Gives the radius of a Gaussian blur to be applied to the  attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If <code>None</code>, defaults to the value supplied to the constructor.</p> <code>None</code> <code>cmap</code> <p>matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If <code>None</code>, defaults to the value supplied to the constructor.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>A <code>np.ndarray</code> array of the numerical representation of the</p> <code>np.ndarray</code> <p>attributions as modified for the visualization. This includes </p> <code>np.ndarray</code> <p>normalization, blurring, etc.</p> Source code in <code>trulens/visualizations.py</code> <pre><code>def __call__(\n    self,\n    attributions,\n    output_file=None,\n    imshow=True,\n    fig=None,\n    return_tiled=False,\n    combine_channels=None,\n    normalization_type=None,\n    blur=None,\n    cmap=None\n) -&gt; np.ndarray:\n\"\"\"\n    Visualizes the given attributions.\n\n    Parameters:\n        attributions:\n            A `np.ndarray` containing the attributions to be visualized.\n\n        output_file:\n            File name to save the visualization image to. If `None`, no\n            image will be saved, but the figure can still be displayed.\n\n        imshow:\n            If true, a the visualization will be displayed. Otherwise the\n            figure will not be displayed, but the figure can still be saved.\n\n        fig:\n            The `pyplot` figure to display the visualization in. If `None`,\n            a new figure will be created.\n\n        return_tiled:\n            If true, the returned array will be in the same shape as the\n            visualization, with no batch dimension and the samples in the\n            batch tiled along the width and height dimensions. If false, the\n            returned array will be reshaped to match `attributions`.\n\n        combine_channels:\n            If `True`, the attributions will be averaged across the channel\n            dimension, resulting in a 1-channel attribution map. If `None`,\n            defaults to the value supplied to the constructor.\n\n        normalization_type:\n            Specifies one of the following configurations for normalizing\n            the attributions (each item is normalized separately):\n\n            - `'unsigned_max'`: normalizes the attributions to the range \n              [-1, 1] by dividing the attributions by the maximum absolute \n              attribution value.\n            - `'unsigned_max_positive_centered'`: same as above, but scales\n              the values to the range [0, 1], with negative scores less than\n              0.5 and positive scores greater than 0.5. \n            - `'magnitude_max'`: takes the absolute value of the \n              attributions, then normalizes the attributions to the range \n              [0, 1] by dividing by the maximum absolute attribution value.\n            - `'magnitude_sum'`: takes the absolute value of the \n              attributions, then scales them such that they sum to 1. If \n              this option is used, each channel is normalized separately, \n              such that each channel sums to 1.\n            - `'signed_max'`: normalizes the attributions to the range \n              [-1, 1] by dividing the positive values by the maximum \n              positive attribution value and the negative values by the \n              minimum negative attribution value.\n            - `'signed_max_positive_centered'`: same as above, but scales \n              the values to the range [0, 1], with negative scores less than\n              0.5 and positive scores greater than 0.5.\n            - `'signed_sum'`: scales the positive attributions such that \n              they sum to 1 and the negative attributions such that they\n              scale to -1. If this option is used, each channel is \n              normalized separately.\n            - `'01'`: normalizes the attributions to the range [0, 1] by \n              subtracting the minimum attribution value then dividing by the\n              maximum attribution value.\n            - `'unnormalized'`: leaves the attributions unaffected.\n\n            If `None`, defaults to the value supplied to the constructor.\n\n        blur:\n            Gives the radius of a Gaussian blur to be applied to the \n            attributions before visualizing. This can be used to help focus\n            on salient regions rather than specific salient pixels. If\n            `None`, defaults to the value supplied to the constructor.\n\n        cmap: matplotlib.colors.Colormap | str, optional\n            Colormap or name of a Colormap to use for the visualization. If\n            `None`, defaults to the value supplied to the constructor.\n\n    Returns:\n        A `np.ndarray` array of the numerical representation of the\n        attributions as modified for the visualization. This includes \n        normalization, blurring, etc.\n    \"\"\"\n    combine_channels, normalization_type, blur, cmap = self._check_args(\n        attributions, combine_channels, normalization_type, blur, cmap\n    )\n\n    # Combine the channels if specified.\n    if combine_channels:\n        attributions = attributions.mean(\n            axis=get_backend().channel_axis, keepdims=True\n        )\n\n    # Blur the attributions so the explanation is smoother.\n    if blur:\n        attributions = self._blur(attributions, blur)\n\n    # Normalize the attributions.\n    attributions = self._normalize(attributions, normalization_type)\n\n    tiled_attributions = self.tiler.tile(attributions)\n\n    # Display the figure:\n    _fig = plt.figure() if fig is None else fig\n\n    plt.axis('off')\n    plt.imshow(tiled_attributions, cmap=cmap)\n\n    if output_file:\n        plt.savefig(output_file, bbox_inches=0)\n\n    if imshow:\n        plt.show()\n\n    elif fig is None:\n        plt.close(_fig)\n\n    return tiled_attributions if return_tiled else attributions\n</code></pre>"},{"location":"api/visualizations/#trulens.visualizations.Visualizer.__init__","title":"<code>__init__(combine_channels=False, normalization_type=None, blur=0.0, cmap=None)</code>","text":"<p>Configures the default parameters for the <code>__call__</code> method (these can  be overridden by passing in values to <code>__call__</code>).</p> <p>Parameters:</p> Name Type Description Default <code>combine_channels</code> <code>bool</code> <p>If <code>True</code>, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map.</p> <code>False</code> <code>normalization_type</code> <code>str</code> <p>Specifies one of the following configurations for normalizing the attributions (each item is normalized separately):</p> <ul> <li><code>'unsigned_max'</code>: normalizes the attributions to the range    [-1, 1] by dividing the attributions by the maximum absolute    attribution value.</li> <li><code>'unsigned_max_positive_centered'</code>: same as above, but scales   the values to the range [0, 1], with negative scores less than   0.5 and positive scores greater than 0.5. </li> <li><code>'magnitude_max'</code>: takes the absolute value of the    attributions, then normalizes the attributions to the range    [0, 1] by dividing by the maximum absolute attribution value.</li> <li><code>'magnitude_sum'</code>: takes the absolute value of the    attributions, then scales them such that they sum to 1. If    this option is used, each channel is normalized separately,    such that each channel sums to 1.</li> <li><code>'signed_max'</code>: normalizes the attributions to the range    [-1, 1] by dividing the positive values by the maximum    positive attribution value and the negative values by the    minimum negative attribution value.</li> <li><code>'signed_max_positive_centered'</code>: same as above, but scales    the values to the range [0, 1], with negative scores less than   0.5 and positive scores greater than 0.5.</li> <li><code>'signed_sum'</code>: scales the positive attributions such that    they sum to 1 and the negative attributions such that they   scale to -1. If this option is used, each channel is    normalized separately.</li> <li><code>'01'</code>: normalizes the attributions to the range [0, 1] by    subtracting the minimum attribution value then dividing by the   maximum attribution value.</li> <li><code>'unnormalized'</code>: leaves the attributions unaffected.</li> </ul> <p>If <code>None</code>, either <code>'unsigned_max'</code> (for single-channel data) or  <code>'unsigned_max_positive_centered'</code> (for multi-channel data) is used.</p> <code>None</code> <code>blur</code> <code>float</code> <p>Gives the radius of a Gaussian blur to be applied to the  attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels.</p> <code>0.0</code> <code>cmap</code> <code>Colormap</code> <p>matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If  <code>None</code>, the colormap will be chosen based on the normalization  type. This argument is only used for single-channel data (including when <code>combine_channels</code> is True).</p> <code>None</code> Source code in <code>trulens/visualizations.py</code> <pre><code>def __init__(\n    self,\n    combine_channels: bool = False,\n    normalization_type: str = None,\n    blur: float = 0.,\n    cmap: Colormap = None\n):\n\"\"\"\n    Configures the default parameters for the `__call__` method (these can \n    be overridden by passing in values to `__call__`).\n\n    Parameters:\n        combine_channels:\n            If `True`, the attributions will be averaged across the channel\n            dimension, resulting in a 1-channel attribution map.\n\n        normalization_type:\n            Specifies one of the following configurations for normalizing\n            the attributions (each item is normalized separately):\n\n            - `'unsigned_max'`: normalizes the attributions to the range \n              [-1, 1] by dividing the attributions by the maximum absolute \n              attribution value.\n            - `'unsigned_max_positive_centered'`: same as above, but scales\n              the values to the range [0, 1], with negative scores less than\n              0.5 and positive scores greater than 0.5. \n            - `'magnitude_max'`: takes the absolute value of the \n              attributions, then normalizes the attributions to the range \n              [0, 1] by dividing by the maximum absolute attribution value.\n            - `'magnitude_sum'`: takes the absolute value of the \n              attributions, then scales them such that they sum to 1. If \n              this option is used, each channel is normalized separately, \n              such that each channel sums to 1.\n            - `'signed_max'`: normalizes the attributions to the range \n              [-1, 1] by dividing the positive values by the maximum \n              positive attribution value and the negative values by the \n              minimum negative attribution value.\n            - `'signed_max_positive_centered'`: same as above, but scales \n              the values to the range [0, 1], with negative scores less than\n              0.5 and positive scores greater than 0.5.\n            - `'signed_sum'`: scales the positive attributions such that \n              they sum to 1 and the negative attributions such that they\n              scale to -1. If this option is used, each channel is \n              normalized separately.\n            - `'01'`: normalizes the attributions to the range [0, 1] by \n              subtracting the minimum attribution value then dividing by the\n              maximum attribution value.\n            - `'unnormalized'`: leaves the attributions unaffected.\n\n            If `None`, either `'unsigned_max'` (for single-channel data) or \n            `'unsigned_max_positive_centered'` (for multi-channel data) is\n            used.\n\n        blur:\n            Gives the radius of a Gaussian blur to be applied to the \n            attributions before visualizing. This can be used to help focus\n            on salient regions rather than specific salient pixels.\n\n        cmap: matplotlib.colors.Colormap | str, optional\n            Colormap or name of a Colormap to use for the visualization. If \n            `None`, the colormap will be chosen based on the normalization \n            type. This argument is only used for single-channel data\n            (including when `combine_channels` is True).\n    \"\"\"\n    self.default_combine_channels = combine_channels\n    self.default_normalization_type = normalization_type\n    self.default_blur = blur\n    self.default_cmap = cmap if cmap is not None else self._get_hotcold()\n\n    # TODO(klas): in the future we can allow configuring of tiling settings\n    #   by allowing the user to specify the tiler.\n    self.tiler = Tiler()\n</code></pre>"}]}