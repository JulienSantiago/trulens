
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../img/favicon.ico">
      <meta name="generator" content="mkdocs-1.3.0, mkdocs-material-8.3.9">
    
    
      
        <title>Distributions - TruLens</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.1d29e8d0.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.cbb835fc.min.css">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
      <link rel="stylesheet" href="../../stylesheets/cover.css">
    
    <script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="trulens" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#distributions-of-interest" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="TruLens" class="md-header__button md-logo" aria-label="TruLens" data-md-component="logo">
      
  <img src="../../img/squid.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            TruLens
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Distributions
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="TruLens" class="md-nav__button md-logo" aria-label="TruLens" data-md-component="logo">
      
  <img src="../../img/squid.png" alt="logo">

    </a>
    TruLens
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../welcome/" class="md-nav__link">
        Welcome to TruLens!
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../install/" class="md-nav__link">
        Installation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../quickstart/" class="md-nav__link">
        Quickstart
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../attribution_parameterization/" class="md-nav__link">
        Attributions for Different Use Cases
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          API Reference
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="API Reference" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          API Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../attribution/" class="md-nav__link">
        Attribution
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../model_wrappers/" class="md-nav__link">
        Models
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../slices/" class="md-nav__link">
        Slices
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../quantities/" class="md-nav__link">
        Quantities
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Distributions
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Distributions
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions" class="md-nav__link">
    trulens.nn.distributions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoI" class="md-nav__link">
    DoI
  </a>
  
    <nav class="md-nav" aria-label="DoI">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoI.__call__" class="md-nav__link">
    __call__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoI.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoI.cut" class="md-nav__link">
    cut()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoI.get_activation_multiplier" class="md-nav__link">
    get_activation_multiplier()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoiCutSupportError" class="md-nav__link">
    DoiCutSupportError
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions.GaussianDoi" class="md-nav__link">
    GaussianDoi
  </a>
  
    <nav class="md-nav" aria-label="GaussianDoi">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.GaussianDoi.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions.LinearDoi" class="md-nav__link">
    LinearDoi
  </a>
  
    <nav class="md-nav" aria-label="LinearDoi">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.LinearDoi.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.LinearDoi.get_activation_multiplier" class="md-nav__link">
    get_activation_multiplier()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions.PointDoi" class="md-nav__link">
    PointDoi
  </a>
  
    <nav class="md-nav" aria-label="PointDoi">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.PointDoi.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../visualizations/" class="md-nav__link">
        Visualizations
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7">
          Resources
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Resources" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          Resources
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="https://truera.github.io/neurips-demo-2021/" class="md-nav__link">
        NeurIPS Demo
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions" class="md-nav__link">
    trulens.nn.distributions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoI" class="md-nav__link">
    DoI
  </a>
  
    <nav class="md-nav" aria-label="DoI">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoI.__call__" class="md-nav__link">
    __call__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoI.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoI.cut" class="md-nav__link">
    cut()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoI.get_activation_multiplier" class="md-nav__link">
    get_activation_multiplier()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions.DoiCutSupportError" class="md-nav__link">
    DoiCutSupportError
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions.GaussianDoi" class="md-nav__link">
    GaussianDoi
  </a>
  
    <nav class="md-nav" aria-label="GaussianDoi">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.GaussianDoi.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions.LinearDoi" class="md-nav__link">
    LinearDoi
  </a>
  
    <nav class="md-nav" aria-label="LinearDoi">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.LinearDoi.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.LinearDoi.get_activation_multiplier" class="md-nav__link">
    get_activation_multiplier()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trulens.nn.distributions.PointDoi" class="md-nav__link">
    PointDoi
  </a>
  
    <nav class="md-nav" aria-label="PointDoi">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trulens.nn.distributions.PointDoi.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


<h1 id="distributions-of-interest">Distributions of Interest<a class="headerlink" href="#distributions-of-interest" title="Permanent link">&para;</a></h1>


  <div class="doc doc-object doc-module">

<a id="trulens.nn.distributions"></a>
    <div class="doc doc-contents first">

      <p>The distribution of interest lets us specify the set of samples over which we 
want our explanations to be faithful. In some cases, we may want to explain the 
model’s behavior on a particular record, whereas other times we may be 
interested in a more general behavior over a distribution of samples.</p>



  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h2 id="trulens.nn.distributions.DoI" class="doc doc-heading">
        <code>
DoI            (<span title="abc.ABC">ABC</span>)
        </code>



<a href="#trulens.nn.distributions.DoI" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Interface for distributions of interest. The <em>Distribution of Interest</em> 
(DoI) specifies the samples over which an attribution method is 
aggregated.</p>

        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">DoI</span><span class="p">(</span><span class="n">AbstractBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interface for distributions of interest. The *Distribution of Interest* </span>
<span class="sd">    (DoI) specifies the samples over which an attribution method is </span>
<span class="sd">    aggregated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">:</span> <span class="n">Cut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;Initialize DoI</span>

<span class="sd">        Parameters:</span>
<span class="sd">            cut (Cut, optional): </span>
<span class="sd">                The Cut in which the DoI will be applied. If `None`, the DoI will be</span>
<span class="sd">                applied to the input. otherwise, the distribution should be applied</span>
<span class="sd">                to the latent space defined by the cut. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cut</span> <span class="o">=</span> <span class="n">cut</span>

    <span class="k">def</span> <span class="nf">_wrap_public_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">model_inputs</span><span class="p">:</span> <span class="n">ModelInputs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">Uniform</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Same as __call__ but input and output types are more specific and</span>
<span class="sd">        less permissive. Formats the inputs for special cases that might be more</span>
<span class="sd">        convenient for the user&#39;s __call__ implementation and formats its return</span>
<span class="sd">        back to the consistent type.&quot;&quot;&quot;</span>

        <span class="n">z</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">om_of_many</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">accepts_model_inputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">model_inputs</span><span class="o">=</span><span class="n">model_inputs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="c1"># Wrap the public doi generator with appropriate type aliases.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DATA_CONTAINER_TYPE</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">Inputs</span><span class="p">(</span><span class="n">Uniform</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

        <span class="n">ret</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">Uniform</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]]</span> <span class="o">=</span> <span class="n">many_of_om</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">innertype</span><span class="o">=</span><span class="n">Uniform</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">model_inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ModelInputs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">Uniform</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the distribution of interest from an initial point. If z:</span>
<span class="sd">        TensorLike is given, we assume there is only 1 input to the DoI layer. If</span>
<span class="sd">        z: List[TensorLike] is given, it provides all of the inputs to the DoI</span>
<span class="sd">        layer. </span>

<span class="sd">        Either way, we always return List[List[TensorLike]] (alias</span>
<span class="sd">        Inputs[Uniform[TensorLike]]) with outer list spanning layer inputs, and</span>
<span class="sd">        inner list spanning a distribution&#39;s instance.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            z:</span>
<span class="sd">                Input point from which the distribution is derived. If</span>
<span class="sd">                list/tuple, the point is defined by multiple tensors.</span>
<span class="sd">            model_inputs:</span>
<span class="sd">                Optional wrapped model input arguments that produce value z at</span>
<span class="sd">                cut.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of points which are all assigned equal probability mass in the</span>
<span class="sd">            distribution of interest, i.e., the distribution of interest is a</span>
<span class="sd">            discrete, uniform distribution over the list of returned points. If</span>
<span class="sd">            z is multi-input, returns a distribution for each input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># @property</span>
    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Cut</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            The Cut in which the DoI will be applied. If `None`, the DoI will be</span>
<span class="sd">            applied to the input. otherwise, the distribution should be applied</span>
<span class="sd">            to the latent space defined by the cut. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cut</span>

    <span class="k">def</span> <span class="nf">_wrap_public_get_activation_multiplier</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">activation</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">model_inputs</span><span class="p">:</span> <span class="n">ModelInputs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Same as get_activation_multiplier but without &quot;one-or-more&quot;. &quot;&quot;&quot;</span>

        <span class="n">activations</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">om_of_many</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>

        <span class="c1"># get_activation_multiplier is public</span>
        <span class="k">if</span> <span class="n">accepts_model_inputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_activation_multiplier</span><span class="p">):</span>
            <span class="n">ret</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_activation_multiplier</span><span class="p">(</span>
                <span class="n">activations</span><span class="p">,</span> <span class="n">model_inputs</span><span class="o">=</span><span class="n">model_inputs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span>
                    <span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_activation_multiplier</span><span class="p">(</span><span class="n">activations</span><span class="p">)</span>

        <span class="n">ret</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">many_of_om</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">get_activation_multiplier</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">activation</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">model_inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ModelInputs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a term to multiply the gradient by to convert from &quot;*influence</span>
<span class="sd">        space*&quot; to &quot;*attribution space*&quot;. Conceptually, &quot;influence space&quot;</span>
<span class="sd">        corresponds to the potential effect of a slight increase in each</span>
<span class="sd">        feature, while &quot;attribution space&quot; corresponds to an approximation of</span>
<span class="sd">        the net marginal contribution to the quantity of interest of each</span>
<span class="sd">        feature.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            activation:</span>
<span class="sd">                The activation of the layer the DoI is applied to. DoI may be</span>
<span class="sd">                multi-input in which case activation will be a list.</span>
<span class="sd">            model_inputs:</span>
<span class="sd">                Optional wrapped model input arguments that produce activation</span>
<span class="sd">                at cut.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An array with the same shape as ``activation`` that will be</span>
<span class="sd">            multiplied by the gradient to obtain the attribution. The default</span>
<span class="sd">            implementation of this method simply returns ``activation``. If</span>
<span class="sd">            activation is multi-input, returns one multiplier for each.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">om_of_many</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_cut_contains_only_one_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DoiCutSupportError</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;Cut provided to distribution of interest was comprised of &#39;</span>
                <span class="s1">&#39;multiple tensors, but `</span><span class="si">{}</span><span class="s1">` is only defined for cuts comprised &#39;</span>
                <span class="s1">&#39;of a single tensor (received a list of </span><span class="si">{}</span><span class="s1"> tensors).</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;Either (1) select a slice where the `to_cut` corresponds to a &#39;</span>
                <span class="s1">&#39;single tensor, or (2) implement/use a `DoI` object that &#39;</span>
                <span class="s1">&#39;supports lists of tensors, i.e., where the parameter, `z`, to &#39;</span>
                <span class="s1">&#39;`__call__` is expected/allowed to be a list of </span><span class="si">{}</span><span class="s1"> tensors.&#39;</span><span class="o">.</span>
                <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">get_backend</span><span class="p">()</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;`</span><span class="si">{}</span><span class="s1">` expected to receive an instance of `Tensor` or &#39;</span>
                <span class="s1">&#39;`np.ndarray`, but received an instance of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="trulens.nn.distributions.DoI.__call__" class="doc doc-heading">
<code class="codehilite language-python"><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">model_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#trulens.nn.distributions.DoI.__call__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Computes the distribution of interest from an initial point. If z:
TensorLike is given, we assume there is only 1 input to the DoI layer. If
z: List[TensorLike] is given, it provides all of the inputs to the DoI
layer. </p>
<p>Either way, we always return List[List[TensorLike]] (alias
Inputs[Uniform[TensorLike]]) with outer list spanning layer inputs, and
inner list spanning a distribution's instance.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>z</code></td>
        <td><code>OM[Inputs, TensorLike]</code></td>
        <td><p>Input point from which the distribution is derived. If
list/tuple, the point is defined by multiple tensors.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>model_inputs</code></td>
        <td><code>Optional[ModelInputs]</code></td>
        <td><p>Optional wrapped model input arguments that produce value z at
cut.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>OM[Inputs, Uniform[TensorLike]]</code></td>
      <td><p>List of points which are all assigned equal probability mass in the
distribution of interest, i.e., the distribution of interest is a
discrete, uniform distribution over the list of returned points. If
z is multi-input, returns a distribution for each input.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="nd">@abstractmethod</span>
<span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">model_inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ModelInputs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">Uniform</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the distribution of interest from an initial point. If z:</span>
<span class="sd">    TensorLike is given, we assume there is only 1 input to the DoI layer. If</span>
<span class="sd">    z: List[TensorLike] is given, it provides all of the inputs to the DoI</span>
<span class="sd">    layer. </span>

<span class="sd">    Either way, we always return List[List[TensorLike]] (alias</span>
<span class="sd">    Inputs[Uniform[TensorLike]]) with outer list spanning layer inputs, and</span>
<span class="sd">    inner list spanning a distribution&#39;s instance.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        z:</span>
<span class="sd">            Input point from which the distribution is derived. If</span>
<span class="sd">            list/tuple, the point is defined by multiple tensors.</span>
<span class="sd">        model_inputs:</span>
<span class="sd">            Optional wrapped model input arguments that produce value z at</span>
<span class="sd">            cut.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of points which are all assigned equal probability mass in the</span>
<span class="sd">        distribution of interest, i.e., the distribution of interest is a</span>
<span class="sd">        discrete, uniform distribution over the list of returned points. If</span>
<span class="sd">        z is multi-input, returns a distribution for each input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="trulens.nn.distributions.DoI.__init__" class="doc doc-heading">
<code class="codehilite language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#trulens.nn.distributions.DoI.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>"Initialize DoI</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>cut</code></td>
        <td><code>Cut</code></td>
        <td><p>The Cut in which the DoI will be applied. If <code>None</code>, the DoI will be
applied to the input. otherwise, the distribution should be applied
to the latent space defined by the cut. </p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">:</span> <span class="n">Cut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;Initialize DoI</span>

<span class="sd">    Parameters:</span>
<span class="sd">        cut (Cut, optional): </span>
<span class="sd">            The Cut in which the DoI will be applied. If `None`, the DoI will be</span>
<span class="sd">            applied to the input. otherwise, the distribution should be applied</span>
<span class="sd">            to the latent space defined by the cut. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_cut</span> <span class="o">=</span> <span class="n">cut</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="trulens.nn.distributions.DoI.cut" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#trulens.nn.distributions.DoI.cut" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">


<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Cut</code></td>
      <td><p>The Cut in which the DoI will be applied. If <code>None</code>, the DoI will be
applied to the input. otherwise, the distribution should be applied
to the latent space defined by the cut. </p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Cut</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns:</span>
<span class="sd">        The Cut in which the DoI will be applied. If `None`, the DoI will be</span>
<span class="sd">        applied to the input. otherwise, the distribution should be applied</span>
<span class="sd">        to the latent space defined by the cut. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cut</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="trulens.nn.distributions.DoI.get_activation_multiplier" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">get_activation_multiplier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">activation</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">model_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#trulens.nn.distributions.DoI.get_activation_multiplier" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Returns a term to multiply the gradient by to convert from "<em>influence
space</em>" to "<em>attribution space</em>". Conceptually, "influence space"
corresponds to the potential effect of a slight increase in each
feature, while "attribution space" corresponds to an approximation of
the net marginal contribution to the quantity of interest of each
feature.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>activation</code></td>
        <td><code>OM[Inputs, TensorLike]</code></td>
        <td><p>The activation of the layer the DoI is applied to. DoI may be
multi-input in which case activation will be a list.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>model_inputs</code></td>
        <td><code>Optional[ModelInputs]</code></td>
        <td><p>Optional wrapped model input arguments that produce activation
at cut.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>OM[Inputs, TensorLike]</code></td>
      <td><p>An array with the same shape as <code>activation</code> that will be
multiplied by the gradient to obtain the attribution. The default
implementation of this method simply returns <code>activation</code>. If
activation is multi-input, returns one multiplier for each.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_activation_multiplier</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">activation</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">model_inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ModelInputs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a term to multiply the gradient by to convert from &quot;*influence</span>
<span class="sd">    space*&quot; to &quot;*attribution space*&quot;. Conceptually, &quot;influence space&quot;</span>
<span class="sd">    corresponds to the potential effect of a slight increase in each</span>
<span class="sd">    feature, while &quot;attribution space&quot; corresponds to an approximation of</span>
<span class="sd">    the net marginal contribution to the quantity of interest of each</span>
<span class="sd">    feature.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        activation:</span>
<span class="sd">            The activation of the layer the DoI is applied to. DoI may be</span>
<span class="sd">            multi-input in which case activation will be a list.</span>
<span class="sd">        model_inputs:</span>
<span class="sd">            Optional wrapped model input arguments that produce activation</span>
<span class="sd">            at cut.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An array with the same shape as ``activation`` that will be</span>
<span class="sd">        multiplied by the gradient to obtain the attribution. The default</span>
<span class="sd">        implementation of this method simply returns ``activation``. If</span>
<span class="sd">        activation is multi-input, returns one multiplier for each.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">om_of_many</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h2 id="trulens.nn.distributions.DoiCutSupportError" class="doc doc-heading">
        <code>
DoiCutSupportError            (<span title="ValueError">ValueError</span>)
        </code>



<a href="#trulens.nn.distributions.DoiCutSupportError" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Exception raised if the distribution of interest is called on a cut whose
output is not supported by the distribution of interest.</p>

        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">DoiCutSupportError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception raised if the distribution of interest is called on a cut whose</span>
<span class="sd">    output is not supported by the distribution of interest.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</code></pre></div>
        </details>


    </div>

  </div>



  <div class="doc doc-object doc-class">



<h2 id="trulens.nn.distributions.GaussianDoi" class="doc doc-heading">
        <code>
GaussianDoi            (<a class="autorefs autorefs-internal" title="trulens.nn.distributions.DoI" href="#trulens.nn.distributions.DoI">DoI</a>)
        </code>



<a href="#trulens.nn.distributions.GaussianDoi" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Distribution representing a Gaussian ball around the point. Used by Smooth
Gradients.</p>

        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">GaussianDoi</span><span class="p">(</span><span class="n">DoI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Distribution representing a Gaussian ball around the point. Used by Smooth</span>
<span class="sd">    Gradients.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">resolution</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cut</span><span class="p">:</span> <span class="n">Cut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">            var:</span>
<span class="sd">                The variance of the Gaussian noise to be added around the point.</span>

<span class="sd">            resolution:</span>
<span class="sd">                Number of samples returned by each call to this DoI.</span>
<span class="sd">            cut (Cut, optional): </span>
<span class="sd">                The Cut in which the DoI will be applied. If `None`, the DoI will be</span>
<span class="sd">                applied to the input. otherwise, the distribution should be applied</span>
<span class="sd">                to the latent space defined by the cut. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GaussianDoi</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var</span> <span class="o">=</span> <span class="n">var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resolution</span> <span class="o">=</span> <span class="n">resolution</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span>
                             <span class="n">TensorLike</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">Uniform</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]]:</span>
        <span class="c1"># Public interface.</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_cut_contains_only_one_tensor</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">gauss_of_input</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="n">TensorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Uniform</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]:</span>
            <span class="c1"># TODO: make a pytorch backend with the same interface to use in places like these.</span>

            <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                <span class="c1"># Tensor implementation.</span>
                <span class="k">return</span> <span class="p">[</span>
                    <span class="n">z</span> <span class="o">+</span> <span class="n">B</span><span class="o">.</span><span class="n">random_normal_like</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_var</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_resolution</span><span class="p">)</span>
                <span class="p">]</span>  <span class="c1"># Uniform</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Array implementation.</span>
                <span class="k">return</span> <span class="p">[</span>
                    <span class="n">z</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var</span><span class="p">),</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_resolution</span><span class="p">)</span>
                <span class="p">]</span>  <span class="c1"># Uniform</span>

        <span class="n">z</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">many_of_om</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">om_of_many</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">gauss_of_input</span><span class="p">,</span> <span class="n">z</span><span class="p">)))</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">










  <div class="doc doc-object doc-method">



<h3 id="trulens.nn.distributions.GaussianDoi.__init__" class="doc doc-heading">
<code class="codehilite language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#trulens.nn.distributions.GaussianDoi.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">


<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>var</code></td>
        <td><code>float</code></td>
        <td><p>The variance of the Gaussian noise to be added around the point.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>resolution</code></td>
        <td><code>int</code></td>
        <td><p>Number of samples returned by each call to this DoI.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>cut</code></td>
        <td><code>Cut</code></td>
        <td><p>The Cut in which the DoI will be applied. If <code>None</code>, the DoI will be
applied to the input. otherwise, the distribution should be applied
to the latent space defined by the cut. </p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">resolution</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cut</span><span class="p">:</span> <span class="n">Cut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters:</span>
<span class="sd">        var:</span>
<span class="sd">            The variance of the Gaussian noise to be added around the point.</span>

<span class="sd">        resolution:</span>
<span class="sd">            Number of samples returned by each call to this DoI.</span>
<span class="sd">        cut (Cut, optional): </span>
<span class="sd">            The Cut in which the DoI will be applied. If `None`, the DoI will be</span>
<span class="sd">            applied to the input. otherwise, the distribution should be applied</span>
<span class="sd">            to the latent space defined by the cut. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">GaussianDoi</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_var</span> <span class="o">=</span> <span class="n">var</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_resolution</span> <span class="o">=</span> <span class="n">resolution</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h2 id="trulens.nn.distributions.LinearDoi" class="doc doc-heading">
        <code>
LinearDoi            (<a class="autorefs autorefs-internal" title="trulens.nn.distributions.DoI" href="#trulens.nn.distributions.DoI">DoI</a>)
        </code>



<a href="#trulens.nn.distributions.LinearDoi" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Distribution representing the linear interpolation between a baseline and 
the given point. Used by Integrated Gradients.</p>

        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">LinearDoi</span><span class="p">(</span><span class="n">DoI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Distribution representing the linear interpolation between a baseline and </span>
<span class="sd">    the given point. Used by Integrated Gradients.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">baseline</span><span class="p">:</span> <span class="n">BaselineLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">resolution</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">cut</span><span class="p">:</span> <span class="n">Cut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The DoI for point, `z`, will be a uniform distribution over the points</span>
<span class="sd">        on the line segment connecting `z` to `baseline`, approximated by a</span>
<span class="sd">        sample of `resolution` points equally spaced along this segment.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            cut (Cut, optional, from DoI): </span>
<span class="sd">                The Cut in which the DoI will be applied. If `None`, the DoI</span>
<span class="sd">                will be applied to the input. otherwise, the distribution should</span>
<span class="sd">                be applied to the latent space defined by the cut. </span>
<span class="sd">            baseline (BaselineLike, optional):</span>
<span class="sd">                The baseline to interpolate from. Must be same shape as the</span>
<span class="sd">                space the distribution acts over, i.e., the shape of the points,</span>
<span class="sd">                `z`, eventually passed to `__call__`. If `cut` is `None`, this</span>
<span class="sd">                must be the same shape as the input, otherwise this must be the</span>
<span class="sd">                same shape as the latent space defined by the cut. If `None` is</span>
<span class="sd">                given, `baseline` will be the zero vector in the appropriate</span>
<span class="sd">                shape. If the baseline is callable, it is expected to return the</span>
<span class="sd">                `baseline`, given `z` and optional model arguments.</span>
<span class="sd">            resolution (int):</span>
<span class="sd">                Number of points returned by each call to this DoI. A higher</span>
<span class="sd">                resolution is more computationally expensive, but gives a better</span>
<span class="sd">                approximation of the DoI this object mathematically represents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LinearDoi</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseline</span> <span class="o">=</span> <span class="n">baseline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resolution</span> <span class="o">=</span> <span class="n">resolution</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">baseline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BaselineLike</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseline</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolution</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">model_inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ModelInputs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">Uniform</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]]:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_cut_contains_only_one_tensor</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="n">z</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">many_of_om</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="n">baseline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_baseline</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">model_inputs</span><span class="o">=</span><span class="n">model_inputs</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="mf">1.</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolution</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolution</span> <span class="o">-</span> <span class="mf">1.</span>

        <span class="k">return</span> <span class="n">om_of_many</span><span class="p">([</span> <span class="c1"># Inputs</span>
            <span class="p">[</span> <span class="c1"># Uniform</span>
                <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">i</span> <span class="o">/</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="n">r</span> <span class="o">*</span> <span class="n">b_</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_resolution</span><span class="p">)</span>
            <span class="p">]</span> <span class="k">for</span> <span class="n">z_</span><span class="p">,</span> <span class="n">b_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)</span>
        <span class="p">])</span>

    <span class="k">def</span> <span class="nf">get_activation_multiplier</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">activation</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">model_inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ModelInputs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a term to multiply the gradient by to convert from &quot;*influence </span>
<span class="sd">        space*&quot; to &quot;*attribution space*&quot;. Conceptually, &quot;influence space&quot;</span>
<span class="sd">        corresponds to the potential effect of a slight increase in each </span>
<span class="sd">        feature, while &quot;attribution space&quot; corresponds to an approximation of</span>
<span class="sd">        the net marginal contribution to the quantity of interest of each </span>
<span class="sd">        feature.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            activation:</span>
<span class="sd">                The activation of the layer the DoI is applied to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The activation adjusted by the baseline passed to the constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">activation</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">many_of_om</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>

        <span class="n">baseline</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_baseline</span><span class="p">(</span>
            <span class="n">activation</span><span class="p">,</span> <span class="n">model_inputs</span><span class="o">=</span><span class="n">model_inputs</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">baseline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">activation</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">activation</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_compute_baseline</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">model_inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ModelInputs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]:</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">()</span>

        <span class="n">_baseline</span><span class="p">:</span> <span class="n">BaselineLike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span>  <span class="c1"># user-provided</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_baseline</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">accepts_model_inputs</span><span class="p">(</span><span class="n">_baseline</span><span class="p">):</span>
                <span class="n">_baseline</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">many_of_om</span><span class="p">(</span>
                    <span class="n">_baseline</span><span class="p">(</span><span class="n">om_of_many</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">model_inputs</span><span class="o">=</span><span class="n">model_inputs</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_baseline</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">many_of_om</span><span class="p">(</span>
                    <span class="n">_baseline</span><span class="p">(</span><span class="n">om_of_many</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">_baseline</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">_baseline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_baseline</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">B</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z_</span><span class="p">)</span> <span class="k">for</span> <span class="n">z_</span> <span class="ow">in</span> <span class="n">z</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_baseline</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">many_of_om</span><span class="p">(</span><span class="n">_baseline</span><span class="p">)</span>
            <span class="c1"># Came from user; could have been single or multiple inputs.</span>

        <span class="c1"># Cast to either Tensor or numpy.ndarray to match what was given in z.</span>
        <span class="k">return</span> <span class="n">nested_cast</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="n">B</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">_baseline</span><span class="p">,</span> <span class="n">astype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  <div class="doc doc-object doc-method">



<h3 id="trulens.nn.distributions.LinearDoi.__init__" class="doc doc-heading">
<code class="codehilite language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#trulens.nn.distributions.LinearDoi.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>The DoI for point, <code>z</code>, will be a uniform distribution over the points
on the line segment connecting <code>z</code> to <code>baseline</code>, approximated by a
sample of <code>resolution</code> points equally spaced along this segment.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>cut</code></td>
        <td><code>Cut, optional, from DoI</code></td>
        <td><p>The Cut in which the DoI will be applied. If <code>None</code>, the DoI
will be applied to the input. otherwise, the distribution should
be applied to the latent space defined by the cut. </p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>baseline</code></td>
        <td><code>BaselineLike</code></td>
        <td><p>The baseline to interpolate from. Must be same shape as the
space the distribution acts over, i.e., the shape of the points,
<code>z</code>, eventually passed to <code>__call__</code>. If <code>cut</code> is <code>None</code>, this
must be the same shape as the input, otherwise this must be the
same shape as the latent space defined by the cut. If <code>None</code> is
given, <code>baseline</code> will be the zero vector in the appropriate
shape. If the baseline is callable, it is expected to return the
<code>baseline</code>, given <code>z</code> and optional model arguments.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>resolution</code></td>
        <td><code>int</code></td>
        <td><p>Number of points returned by each call to this DoI. A higher
resolution is more computationally expensive, but gives a better
approximation of the DoI this object mathematically represents.</p></td>
        <td><code>10</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">baseline</span><span class="p">:</span> <span class="n">BaselineLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">resolution</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">cut</span><span class="p">:</span> <span class="n">Cut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The DoI for point, `z`, will be a uniform distribution over the points</span>
<span class="sd">    on the line segment connecting `z` to `baseline`, approximated by a</span>
<span class="sd">    sample of `resolution` points equally spaced along this segment.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        cut (Cut, optional, from DoI): </span>
<span class="sd">            The Cut in which the DoI will be applied. If `None`, the DoI</span>
<span class="sd">            will be applied to the input. otherwise, the distribution should</span>
<span class="sd">            be applied to the latent space defined by the cut. </span>
<span class="sd">        baseline (BaselineLike, optional):</span>
<span class="sd">            The baseline to interpolate from. Must be same shape as the</span>
<span class="sd">            space the distribution acts over, i.e., the shape of the points,</span>
<span class="sd">            `z`, eventually passed to `__call__`. If `cut` is `None`, this</span>
<span class="sd">            must be the same shape as the input, otherwise this must be the</span>
<span class="sd">            same shape as the latent space defined by the cut. If `None` is</span>
<span class="sd">            given, `baseline` will be the zero vector in the appropriate</span>
<span class="sd">            shape. If the baseline is callable, it is expected to return the</span>
<span class="sd">            `baseline`, given `z` and optional model arguments.</span>
<span class="sd">        resolution (int):</span>
<span class="sd">            Number of points returned by each call to this DoI. A higher</span>
<span class="sd">            resolution is more computationally expensive, but gives a better</span>
<span class="sd">            approximation of the DoI this object mathematically represents.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">LinearDoi</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_baseline</span> <span class="o">=</span> <span class="n">baseline</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_resolution</span> <span class="o">=</span> <span class="n">resolution</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="trulens.nn.distributions.LinearDoi.get_activation_multiplier" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">get_activation_multiplier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">activation</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">model_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#trulens.nn.distributions.LinearDoi.get_activation_multiplier" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Returns a term to multiply the gradient by to convert from "<em>influence 
space</em>" to "<em>attribution space</em>". Conceptually, "influence space"
corresponds to the potential effect of a slight increase in each 
feature, while "attribution space" corresponds to an approximation of
the net marginal contribution to the quantity of interest of each 
feature.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>activation</code></td>
        <td><code>OM[Inputs, TensorLike]</code></td>
        <td><p>The activation of the layer the DoI is applied to.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Inputs[TensorLike]</code></td>
      <td><p>The activation adjusted by the baseline passed to the constructor.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_activation_multiplier</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">activation</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">model_inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ModelInputs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a term to multiply the gradient by to convert from &quot;*influence </span>
<span class="sd">    space*&quot; to &quot;*attribution space*&quot;. Conceptually, &quot;influence space&quot;</span>
<span class="sd">    corresponds to the potential effect of a slight increase in each </span>
<span class="sd">    feature, while &quot;attribution space&quot; corresponds to an approximation of</span>
<span class="sd">    the net marginal contribution to the quantity of interest of each </span>
<span class="sd">    feature.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        activation:</span>
<span class="sd">            The activation of the layer the DoI is applied to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The activation adjusted by the baseline passed to the constructor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">activation</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">many_of_om</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>

    <span class="n">baseline</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_baseline</span><span class="p">(</span>
        <span class="n">activation</span><span class="p">,</span> <span class="n">model_inputs</span><span class="o">=</span><span class="n">model_inputs</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">baseline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">activation</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">activation</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)]</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h2 id="trulens.nn.distributions.PointDoi" class="doc doc-heading">
        <code>
PointDoi            (<a class="autorefs autorefs-internal" title="trulens.nn.distributions.DoI" href="#trulens.nn.distributions.DoI">DoI</a>)
        </code>



<a href="#trulens.nn.distributions.PointDoi" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Distribution that puts all probability mass on a single point.</p>

        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">PointDoi</span><span class="p">(</span><span class="n">DoI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Distribution that puts all probability mass on a single point.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">:</span> <span class="n">Cut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;Initialize PointDoI</span>

<span class="sd">        Parameters:</span>
<span class="sd">            cut (Cut, optional): </span>
<span class="sd">                The Cut in which the DoI will be applied. If `None`, the DoI will be</span>
<span class="sd">                applied to the input. otherwise, the distribution should be applied</span>
<span class="sd">                to the latent space defined by the cut. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PointDoi</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">TensorLike</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">model_inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ModelInputs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OM</span><span class="p">[</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">Uniform</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]]:</span>

        <span class="n">z</span><span class="p">:</span> <span class="n">Inputs</span><span class="p">[</span><span class="n">TensorLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">many_of_om</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">om_of_many</span><span class="p">([</span>
            <span class="p">[</span><span class="n">z_</span><span class="p">]</span>  <span class="c1"># a point Uniform</span>
            <span class="k">for</span> <span class="n">z_</span> <span class="ow">in</span> <span class="n">z</span>
        <span class="p">])</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">










  <div class="doc doc-object doc-method">



<h3 id="trulens.nn.distributions.PointDoi.__init__" class="doc doc-heading">
<code class="codehilite language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#trulens.nn.distributions.PointDoi.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>"Initialize PointDoI</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>cut</code></td>
        <td><code>Cut</code></td>
        <td><p>The Cut in which the DoI will be applied. If <code>None</code>, the DoI will be
applied to the input. otherwise, the distribution should be applied
to the latent space defined by the cut. </p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>trulens/nn/distributions.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">:</span> <span class="n">Cut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;Initialize PointDoI</span>

<span class="sd">    Parameters:</span>
<span class="sd">        cut (Cut, optional): </span>
<span class="sd">            The Cut in which the DoI will be applied. If `None`, the DoI will be</span>
<span class="sd">            applied to the input. otherwise, the distribution should be applied</span>
<span class="sd">            to the latent space defined by the cut. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">PointDoi</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>







  </div>

    </div>

  </div>

              
            </article>
            
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="Footer" >
      
        
        <a href="../quantities/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Quantities" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Quantities
            </div>
          </div>
        </a>
      
      
        
        <a href="../visualizations/" class="md-footer__link md-footer__link--next" aria-label="Next: Visualizations" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Visualizations
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.6c7ad80a.min.js"></script>
      
        <script src="../../javascript/config.js"></script>
      
        <script src="../../javascript/app.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="../../javascript/tex-mml-chtml-3.0.0.js"></script>
      
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
      
    
  </body>
</html>